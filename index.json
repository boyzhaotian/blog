[{"content":"","cover":"/blog/images/ink-with-travis-ci.png","link":"「hello world」 via ink.html","preview":"\u003cp\u003e如果你希望拥有自己的博客，一个简洁、美观，能让你安静写字的地方，不妨尝试一下「纸小墨Ink」这个工具。这篇文章详细讲解了它的使用方法，以及如何通过「Travis CI」来部署。\u003c/p\u003e\n","title":"「Hello World」via Ink \u0026 Travis CI"},{"content":"\n\n# 变量类型和计算\n    JS 中使用 typeof 能得到哪些类型\n    何时使用 === 何时使用 == \n    JS 中有哪些内置函数\n    JS 变量按照存储方式区分为哪些类型，并描述特点\n    如何理解JSON\n\n## 变量类型\n- 值类型 vs 引用类型\n    ```js\n    // 值类型\n    var a = 100\n    var b = a\n    a = 200\n    console.log(b)  // 100\n\n    // 引用类型 \n    // 对象、数组、函数，都具有对象特性，可无限扩展属性\n    var a = {age:20}\n    var b = a\n    b.age = 21\n    console.log(a.age)  // 21\n    ```\n- typeof 运算符详解\n    ```js\n    typeof undefined    // undefined\n    typeof 'abc'    // string\n    typeof 123    // number\n    typeof true    // boolean\n    // type 只能区分值类型\n    typeof {}    // object\n    typeof []    // object\n    typeof null    // object\n    // 不能区分引用类型\n    typeof console.log()    // function\n    ```\n## 变量计算\n\n- 强制类型转换\n    - 字符串拼接\n        ```js\n        var a = 100 + 10    // 110\n        var b = 100 + '10'  // '10010'\n        ```\n    - == 运算符 （ 判断值相等 ）\n        ```js\n        100 == '100'    // true\n        0 == ''  // true\n        null == undefined   //true\n        ```\n    - if 语句\n        ```js\n        var a = true\n        if (a) {    // true\n            // ...\n        }\n        var b = 100\n        if (b) {    // true\n            // ...\n        }\n        var c = ''\n        if (c) {    // false\n            // ...\n        }\n        ```\n    - 逻辑运算\n        ```js\n        console.log(10 \u0026\u0026 0)   // 0\n        console.log('' \u0026\u0026 'abc')   // 'abc'\n        console.log(!window.abc)   // true\n\n        // 判断一个变量会被当做 true 还是 false\n        var a = 100\n        console.log(!!a)   // true\n        ```\n\u003e if中强制转换成false的有：0、''、NaN、null、false\n\n### 何时使用 === 和 ==\n```js\n// 除了下面情况，全部使用 === 判断相等\nif (obj.a == null) {\n    // 这里相当于 obj.a === null || obj.a === undefined ，简写形式\n    // 这是 jquery 源码中推荐的写法\n}\n```\n\u003e 看对象属性是否存在的时候用 == null（对象属性不存在不会报错）\n\n\n### JS中的内置函数 —— 数据封装类对象\n```js\nFunction\nArray\nObject\nDate\nRegExp\nBoolean\nNumber\nError\n```\n\n### 内置对象：Math、JSON（两个API）\n```js\n// JSON 是一种数据格式 也是 JS 对象\nJSON.stringify({a:10, b:20})\nJSON.parse('{\"a\":10,\"b\":20}')\n```\n\n\n# 原型链\n    如何准确判断一个变量是数组类型\n    写一个原型链继承的例子\n    描述 new 一个对象的过程\n    zepto（ 或其他框架 ）代码中如何使用原型链\n## 构造函数\n```js\nfunction Foo(name, age) {\n    this.name = name\n    this.age = age\n    this.class = 'class-1'\n    // return this  // 默认有这行\n}\nvar f = new Foo('zhangsan', 20)\n//var f = new Foo('lisi', 22)   // 创建多个对象\n```\n- new 的过程 this  \n    ```js\n    // 生成空对象 this ，添加属性，返回 this\n    function Foo(name, age) {\n        // this = {}\n        this.age = age\n        // return this  \n    }\n    ```\n## 构造函数 - 扩展\n- var a = {} 其实是 var a = new Object() 的语法糖\n- var a = [] 其实是 var a = new Array() 的语法糖\n- functino Foo(){...} 其实是 var Foo = new Function(...) 的语法糖\n- 使用 instanceof 判断一个函数是否是一个变量的构造函数\n## 原型规则和示例\n\n- 所有的引用类型（数组、对象、函数），都具有对象是特性，即可以自由扩展属性（除了\"null\"以外）\n    ```js\n    var obj = {}; obj.a = 100;\n    var arr = []; arr.a = 100;\n    function fn () {}\n    fn.a = 100;\n    ```\n- 所有的引用类型（数组、对象、函数），都有一个隐式原型__proto__属性，属性是一个普通对象。\n    ```js\n    console.log(obj.__proto__);\n    console.log(arr.__proto__);\n    console.log(fn.__proto__);\n    ```\n- 所有的函数，都有一个显式原型protoype属性，属性值也是一个普通对象。\n    ```js\n    console.log(fn.prototype);\n    ```\n- 所有的引用类型（数组、对象、函数），隐式原型__proto__属性指向它的构造函数的显式原型prototype属性。\n    ```js\n    console.log(obj.__proto__ === Object.prototype);\n    ```\n- 当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去他的__proto__（即它的构造函数的prototype）中去找。\n    ```js\n    function Foo(name, age) {\n        this.name = name\n    }\n    Foo.prototype.alertName = function () {\n        alert(this.name)\n    }\n    // 创建实例\n    var f = new Foo('zhangsan')\n    f.printName = function () {\n        console.log(this.log)\n    }\n    // 测试\n    f.printName()\n    f.alertName()\n    ```\n### 循环对象的自身属性\n```js\nvar item\nfor (item in f) {\n    // 高级浏览器已经在 for ... in 中屏蔽了来自原型的属性\n    // 但是建议大家还是加上这个判断，保证程序的健壮性\n    if (f.hasOwnProperty(item)) {\n        console.log(item)\n    }\n}\n```\n\n## 原型链\n\u003c!-- ![image](https://boyzhaotian.netlify.com/原型链.png) --\u003e\n```js\nfunction Foo(name, age) {\n    this.name = name\n}\nFoo.prototype.alertName = function () {\n    alert(this.name)\n}\n// 创建实例\nvar f = new Foo('zhangsan')\nf.printName = function () {\n    console.log(this.log)\n}\n// 测试\nf.printName()\nf.alertName()\nf.toString()    // 要去 f.__proto__.__proto__中查找\n```\n\u003e 原型链为防止死循环： Object.prototype.\\_\\_proto__ === null  \n\n## instanceof\n- f instanceof Foo 的判断逻辑是\n    - f 的 __proto__ 一层一层往上，能否对应到 Foo.prototype\n    - 再试着判断 f instanceof Object\n\n\u003e f instanceof Foo、Object都为true\n\n## 解答\n- 如何准确判断一个变量是数组类型？\n    ```js\n    var arr = []\n    arr instanceof Array    // true\n    typeof arr  // object，typeof 是无法判断是否是数组的\n    ```\n- 写一个原型链继承的例子\n    ```js\n    function Elem(id) {\n        this.elem = document.getElementById(id)\n    }\n    Elem.prototype.html = function (val) {\n        var elem = this.elem\n        if (val) {\n            elem.innerHTML = val\n            return this //链式操作\n        } else {\n            return elem.innerHTML\n        }\n    }\n    Elem.prototype.on = function (type, fn) {\n        var elem = this.elem\n        elem.addEventListener(type, fn)\n        return this\n    }\n    var div1 = new Elem('div1')\n    div1.html('\u003cp\u003ehello\u003c/p\u003e').on('click', function(){\n        console.log('clicked')\n    }).html('\u003cp\u003ejavascript\u003c/p\u003e')\n    ```\n- 描述 new 一个对象的过程\n    - 创建一个新对象\n    - this 指向这个新对象\n    - 执行代码，即对 this 赋值\n    - 返回 this\n- zepto（ 或其他框架 ）源码中如何使用原型链\n    - 阅读源码是高效提高技能的方式\n    - 但不能『埋头苦钻』有技巧在其中\n    - 慕课网搜索『zeoto设计和源码分析』\n\n\n# 作用域（Scope）和闭包（Closure）\n\n    说一下对变量提升的理解\n    说明 this 几种不同的使用场景\n    创建 10 个 \u003ca\u003e 标签，点击的时候弹出来对应的序号\n    如何理解作用域\n    实际开发中闭包的应用\n\n## 执行上下文\n- 执行上下文深入理解\n    \n    [深入理解javascript原型和闭包（8）——简述【执行上下文】上](https://www.cnblogs.com/wangfupeng1988/p/3986420.html )\n \n- 执行上下文和作用域的关系  \n    在一个函数被执行时，创建的执行上下文对象除了保存了些代码执行的信息，还会把当前的作用域保存在执行上下文中。所以它们的关系只是存储关系。\n\n```js\nconsole.log(a)  // undefined\nvar a = 100\n\nfn('zhangsan')  // 'zhangsan' 20\nfunction fn (name) {\n    age = 20\n    console.log(name, age)\n    var age\n}\n```\n- 范围：一段\\\u003cscript\u003e或者一个函数  \n- 全局：变量定义、函数声明（一段\\\u003cscript\u003e）  \n- 函数：变量定义、函数声明、this赋值、arguments（函数）  \n\u003e 注意函数声明和函数表达式的区别\n\n## THIS\n- this 指向要在执行时才能确认值，定义时无法确认\n    ```js\n    var a = {\n        name: 'A',\n        fn: function () {\n            console.log(this.name);\n        }\n    }\n    a.fn()  // this === a\n    a.fn.call({name: 'B'})  // this === {name: 'B'}\n    var fn1 = a.fn\n    fn1() // this === window\n    ```\n- 使用场景\n    - 作为构造函数执行 -\u003e 实例\n    - 作为对象属性执行 -\u003e 引用者\n    - 作为普通函数执行 -\u003e window\n    - call、apply、bind -\u003e 传入的第一个参数\n\n## 作用域（Scope）\n- JS没有块级作用域\n    ```js\n    // 无块级作用域\n    if (true) {\n        var name = 'zhangsan'\n    }\n    console.log(name);  // zhangsan\n    ```\n- 只有函数和全局作用域\n    ```js\n    // 函数和全局作用域\n    var a = 100\n    function fn() {\n        var a = 200\n        console.log('fn', a);\n    }\n    console.log('global', a);   // global 100\n    fn()    // fn 200\n    ```\n\n## 作用域链\n- 即自由变量的查找路径  \n- 函数的父级作用域根据定义的位置来判断，并非执行位置。\n### 自由变量  \n```js\nvar a = 100\nfunction F1() {\n    var b = 200\n    function F2() {\n        var c = 300\n        // 当前作用域没有定义的变量，即\"自由变量\"\n        console.log(a); // a 是自由变量\n        console.log(b); // b 是自由变量\n        console.log(c);\n    }\n    F2()\n}\nF1()\n```\n\n\n## 闭包\n- 使用场景\n    - 函数作为返回值\n        ```js\n        function F1() {\n            var a = 100\n            // 返回一个函数（函数作为返回值）\n            return funtion () {\n                console.log(a)  // 自由变量，父作用域寻找\n            }\n        }\n        // f1 得到一个函数\n        var f1 = F1()\n        var a = 200\n        fn()    // 100\n        ```\n    - 函数作为参数传递  \n        ```js\n        function F1 () {\n            var a = 100\n            // 返回一个函数（函数作为返回值）\n            return funtion () {\n                console.log(a)  // 自由变量，父作用域寻找\n            }\n        }\n        var f1 = F1()\n        function F2（fn）{\n            var a = 200\n            fn()\n        }\n        F2(f1)\n        ```\n## 解题\n- 说一下对变量提升的理解\n    - 变量定义\n    - 函数声明（ 注意和函数表达式的区别 ）\n- 说明 this 几种不同的使用场景\n    - 作为构造函数执行 -\u003e 实例\n    - 作为对象属性执行 -\u003e 引用者\n    - 作为普通函数执行 -\u003e window\n    - call、apply、bind -\u003e 传入的第一个参数\n- 创建 10 个 \\\u003ca\u003e 标签，点击的时候弹出来对应的序号\n    ```js\n    var i, frag = document.createDocumentFragment()\n    for (i = 0; i \u003c 10; i++) {\n        (function (i) {\n            var a = document.createElement('a')\n            a.innerHTML = i + '\u003cbr\u003e'\n            a.addEventListener('click', function (e) {\n                e.preventDefault()\n                alert(i)\n            })\n            frag.appendChild(a)\n        })(i)\n    }\n    document.body.appendChild(frag)\n    ```\n- 如何理解作用域\n    - 自由变量\n    - 作用域链，即自由变量的查找\n    - 闭包的两个场景\n- 实际开发中的闭包应用\n    - 封装变量\n    - 收敛权限\n    ```js\n    function isFirstLoad() {\n        var _list = []\n        return function (id) {\n            if (_list.indexOf(id) \u003e= 0) {\n                return false\n            } else {\n                _list.push(id)\n                return true\n            }\n        }\n    }\n    var firstLoad = isFirstLoad()\n    firstLoad(10) //true\n    firstLoad(10) //false\n    firstLoad(20) //true\n    firstLoad(20) //false\n    // 在 isFirstLoad 函数外面，根本不可能修改掉 _list 的值\n    ```\n\n\n# 异步和单线程  \n    同步和异步的区别是什么？分别举一个同步和异步的例子  \n    一个关于 setTimeout 的笔试题\n    前端使用异步的场景有哪些\n- 什么是异步（ 对比同步 ）\n    ```js\n    console.log(100)\n    setTimeout(function () {\n        console.log(200)\n    }, 1000)    // 异步\n    alert(300)  // 同步阻塞\n    console.log(400)\n    ```\n    - 何时需要异步\n        - 在可能发生等待的情况\n        - \u0008等待过程中不能像 alert 一样阻塞程序运行\n        - 因此，所有的『等待的情况』都需要异步\n- 前端使用异步的场景\n    - 定时任务：setTimeout，setInterval  \n    ```js\n    setTimeout(function () {\n\n    }, 0)\n    ```\n\n    - 网络请求：ajax请求，动态\\\u003cimg\u003e加载  \n    ```js\n    $.get('/test.json', function (data) {\n        console.log(data)\n    })\n    var img = document.createElement('img')\n    img.onload = function () {\n        console.log('loaded')\n    }\n    ```\n    - 事件绑定\n    ```js\n    var btn1 = document.getElementById('btn1')\n    btn1.addEventListener('click', function (e) {\n        console.log('clicked')\n    })\n    ```\n## 解题\n- 同步和异步的区别是什么？分别举一个同步和异步的例子  \n    - 同步会阻塞代码执行，而异步不会\n    - alert 是同步的，setTimeout 是异步的\n- 一个关于 setTimeout 的笔试题\n\n- 前端使用异步的场景有哪些\n    - 定时任务：setTimeout，setInterval  \n    - 网络请求：ajax请求，动态\\\u003cimg\u003e加载  \n    - 事件绑定\n# 日期和Math\n    获取 2017-06-10 格式的日期\n    获取随机数，要求是长度已知的字符串格式\n    写一个能遍历对象和数组的通用 forEach 函数\n## 日期\n```js\nDate.now()  //获取当前时间毫秒数\nvar dt = new Date()\ndt.getTime()    //获取毫秒数\ndt.getFullYear()    //年\ndt.getMonth()    //月（0 - 11）\ndt.getDate()    //日（0 - 31）\ndt.getHours()    //小时（0 - 23）\ndt.getMinutes()    //分（0 - 59）\ndt.getSeconds()    //秒（0 - 59）\n```\n## Math\n- 获取随机数 Math.random() -\u003e [0-1]\n\n# 数组和对象的API  \n## 数组\n- forEach 遍历所有元素  \n    ```js\n    var arr = [1,2,3]\n    arr.forEach(function (item, index) {\n        console.log(index, item)\n    })\n    ```\n- every 判断所有元素是否都符合条件  \n    ```js\n    var arr = [1,2,3]\n    var result = arr.every(function (item, index) {\n        if (item \u003c 2) {\n            return true\n        }\n    })\n    console.log(result) // false\n    ```\n- some 判断是否至少有一个元素符合条件  \n    ```js\n    var arr = [1,2,3]\n    var result = arr.some(function (item, index) {\n        if (item \u003c 2) {\n            return true\n        }\n    })\n    console.log(result) // true\n    ```\n- sort 排序  \n    ```js\n    var arr = [1,4,2,3,5]\n    var result = arr.sort(function (a, b) {\n        return a - b    // 从小到大\n    })\n    console.log(result)\n    ```\n- map 对元素重新组装，生成新数组\n    ```js\n    var arr = [1,4,2,3,5]\n    var arr2 = arr.map(function (item, index) {\n        return '\u003cb\u003e' + item + '\u003c/b\u003e'\n    })\n    console.log(result)\n    ```\n- filter 过滤符合条件的元素  \n    ```js\n    var arr = [1,4,2,3,5]\n    var arr2 = arr.filter(function (item, index) {\n        if (item \u003e= 2) {\n            return true\n        }\n    })\n    console.log(result)\n    ```\n## 对象  \n- for...in 遍历对象\n    ```js\n    var obj = {\n        a: 100,\n        b: 200,\n        c: 300\n    }\n    for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            console.log(key, obj[key])\n        }\n    }\n    ```\n## 解答\n- 获取 2017-06-10 格式的日期\n    ```js\n    function formatDate(dt) {\n        if (!dt) {\n            dt = new Date()\n        }\n        var year = dt.getFullYear()\n        var month = dt.getMonth() + 1\n        var date = dt.getDate()\n        if (month \u003c 10) {\n            month = '0' + month\n        }\n        if (date \u003c 10) {\n            date = '0' + date\n        }\n        return year + '-' + month + '-' + date\n    }\n    console.log(formatDate());\n    ```\n- 获取随机数，要求是长度已知的字符串格式\n    ```js\n    var random = Math.random()\n    var random = random + '0000000000'  // 后面加上 10 个零\n    var random = random.slice(0, 10)\n    console.log(random)\n    ```\n- 写一个能遍历对象和数组的通用 forEach 函数\n    ```js\n    function forEach(obj, fn) {\n        var key\n        if (obj instanceof Array) {\n            obj.forEach(function (item, index) {\n                fn(index, item)\n            })\n        } else {\n            for (key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    fn(key, obj[key])\n                }\n            }\n        }\n    }\n    var arr = [1,2,3]\n    forEach(arr, function (index, item) {\n        console.log(index, item);\n    })\n    var obj = {x: 100, y:200}\n    forEach(obj, function (key, value) {\n        console.log(key, value);    \n    })\n\n    ```\n\n# JS-WEB API\n- JS基础知识：EMCA 262 标准（基础语法）\n    - 变量类型\n    - 原型\n    - 作用域和异步\n- JS-WEB-API：W3C标准（基础库）  \n    - 浏览器操作页面的API\n        - DOM操作  \n        - BOD操作  \n        - 事件绑定  \n        - ajax请求（包括http协议）  \n        - 存储  \n    - 全局对象及函数  \n        - Object, Array, Boolean, String, Math, JSON 等\n        - window, document\n        - navigator\n\n\n## DOM操作（Document Object Model） \n\n    DOM 是哪种基本结构？\n    DOM 操作常用 API 有哪些\n    DOM节点的 attr 和 property 有何区别？  \n\n- DOM 本质\n\u003e 就是将XML（或者HTML）内的节点定义成基本统一的对象数据可以供程序语言（如javaScript）控制的技术规范。\n- DOM 节点操作\n    - 获取 DOM 节点\n        ```js\n        var div1 = document.getElementById('div1')  // 元素\n        var divList = document.getElementsByTagName('div')  // 集合\n        var divList = document.getElementsByClassName('div')  // 集合\n        var divList = document.querySelectorAll('div')  // 集合\n        ```\n    - prototype\n        ```js\n        var p = document.getElementById('p')  // 元素\n        console.log(p.style.width)  // 获取样式\n        p.style.width = '100px' // 修改样式\n        ```\n    - Attribute\n        ```js\n        var p = document.getElementById('p')  // 元素\n        console.log(p.getAttribute('data-name'))  // 获取样式\n        p.getAttribute('data-name') = 'p2' // 修改样式\n        ```\n- DOM 结构操作\n    - 新增节点\n        ```js\n        var div1 = document.getElementById('div1')\n        // 添加新节点\n        var p1 = document.createElement('p')\n        p1.innerHtml = 'this is p1'\n        div1.appendChild(p1)    // 添加新创建的元素\n        // 移动已有节点\n        var p2 = document.getElementById('p2')\n        div1.appendChild(p2)\n        ```\n    - 获取父元素\n        ```js\n        var parent = div1.parentElement\n        ```\n    - 获取子元素\n        ```js\n        var child = div1.childNodes\n        ```\n    - 删除节点\n        ```js\n        div1.removeChild(child[0])\n        ```\n\n### 解题\n- DOM 是哪种基本结构？\n    - 树\n- DOM 操作常用 API 有哪些\n    - 获取 DOM 节点，以及节点的 property 和 attibute\n    - 获取父节点，获取子节点\n    - 新增节点，删除节点\n\n- DOM节点的 attr 和 property 有何区别？  \n    - property 只是一个 JS 对象的属性的修改  \n    - Attribute 是对 html 标签属性的修改\n\n## BOM操作（Browser Object Model）\n\n    如何检测浏览器类型 \n    拆解url的各部分\n\n- 如何检测浏览器类型  \n    - navigator（userAgent）  \n        ```js\n        var ua = navigator.userAgent\n        var isChrome = ua.indexOf('Chrome')\n        ```\n    - screen（width、height）  \n        ```js\n        console.log(screen.width)\n        console.log(screen.height)\n        ```\n- 拆解url的各部分  \n    - location（href、protocol、pathname、search、hash）  \n        ```js\n        console.log(location.href)\n        console.log(location.protocol)\n        console.log(location.host)\n        console.log(location.pathname)\n        console.log(location.search)\n        console.log(location.hash)\n        ```\n    - history（back、forward）\n        ```js\n        history.back()\n        history.forward()\n        ```\n## 事件  \n\n    编写一个通用的事件监听函数\n    描述事件冒泡流程\n    冒泡的应用\n\n- 编写一个通用的事件监听函数（ 通用事件绑定 ）\n    ```js\n    //通用事件绑定\n    function bindEvent (elem, type, fn) {\n        elem.addEventListener(type, fn)\n    }\n    //通用事件绑定 + 事件代理\n    function bindEvent (elem, type, selector, fn) {\n        if (fn == null) {\n            fn = selector\n            selector = null\n        }\n        elem.addEventListener(type, function (e) {\n            var target\n            if (selector) {\n                target = e.target\n                if (target.matches(selector)) {\n                    fn.call(target, e)\n                }\n            } else {\n                fn(e)\n            }\n        })\n    }\n    var div1 = document.getElementById('div1')\n    bindEvent(div1, 'click', 'a', function(e) {\n        console.log(this.innerHTML);\n    })\n    ```\n    \u003e 关于IE低版本的兼容性  \n    IE低版本使用attachEvent绑定事件，和W3C标准不一样\n\n- 描述事件冒泡流程（事件冒泡）  \n    - DOM树形结构  \n    - 事件冒泡  \n    - 阻止冒泡  \n        - event.stopPropagation() 不再派发事件。   \n            终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。\n            ```html\n            \u003cbody\u003e\n                \u003cdiv id = 'div1'\u003e\n                    \u003cp id = 'p1'\u003e激活\u003c/p\u003e\n                    \u003cp id = 'p2'\u003e取消\u003c/p\u003e\n                    \u003cp id = 'p3'\u003e取消\u003c/p\u003e\n                    \u003cp id = 'p4'\u003e取消\u003c/p\u003e\n                \u003c/div\u003e\n                \u003cdiv id = 'div2'\u003e\n                    \u003cp id = 'p5'\u003e取消\u003c/p\u003e\n                    \u003cp id = 'p6'\u003e取消\u003c/p\u003e\n                \u003c/div\u003e\n            \u003c/body\u003e\n            ```\n            ```js\n            var p1 = document.getElementById('p1')\n            var body = document.body\n            bindEvent(p1, 'click', function (e) {\n                e.stopPropagation()\n                alert('激活')\n            })\n            bindEvent(body, 'click', function (e) {\n                e.stopPropagation()\n                alert('取消')\n            })\n            ```\n    - 冒泡的应用（代理）  \n        - 代码简洁\n        - 减少浏览器内存的占用\n        ```html\n        \u003cdiv id = 'div1'\u003e\n            \u003ca href='#'\u003ea1\u003c/a\u003e\n            \u003ca href='#'\u003ea2\u003c/a\u003e\n            \u003ca href='#'\u003ea3\u003c/a\u003e\n            \u003ca href='#'\u003ea4\u003c/a\u003e\n        \u003c/div\u003e\n        ```\n        ```js\n        var div1 = document.getElementById('div1')\n        bindEvent(div1, 'click', function (e) {\n            var target = e.target\n            if (target.nodeName === 'A') {\n                alert(trget.innerHTML)\n            }\n        })\n        ```\n\n- 对于一个无限下拉加载图片的页面，如何绑定事件\n    - 使用代理  \n    - 知道代理的两个优点（绑定次数少，浏览器压力小）  \n\n## AJAX\n    手动编写一个ajax，不依赖第三方库\n    跨域的几种实现方式    \n- XMLHttpRequest  \n    ```js\n    var xhr = new XMLHttpRequest()\n    xhr.open(\"GET\", \"./api\", false)\n    xhr.onreadystatechange = function () {\n        //这里的函数异步执行\n        if (xhr.readyState == 4) {\n            if (xhr.status == 200) {\n                console.log(xhr.responseText);\n            }\n        }\n    }\n    xhr.send(null)\n    ```\n    \u003e 关于IE低版本的兼容性  \n    IE低版本使用ActiveXObject，和W3C标准不一样\n- 状态码说明\n    - readyState  \n        0 - （未初始化）还没有调用send()方法  \n        1 - （载入）已调用send()方法，\u0008正在发送请求  \n        2 - （载入完成）send()方法执行完成，已经接收到全部响应内容  \n        3 - （交互）正在解析响应内容  \n        4 - （完成）响应内容解析完成，可以在客户端调用了\n    - status  \n        2xx - 表示成功处理请求。如200  \n        3xx - 需要重定向，浏览器直接跳转  \n        4xx - 客户端请求错误，如404  \n        5xx - 服务器错误  \n- 跨域  \n    - 定义：浏览器有同源策略，不允许ajax访问其他域的接口  \n    - 跨域条件：协议、域名、端口，有一个不同就算跨域\n    -  可以跨域的三个标签\n        - \\\u003cimg\u003e  \n            用于打点统计，统计网站可能是其他域  \n            标签古老，不存在兼容性问题\n        - \\\u003clink\u003e、\\\u003cscript\u003e  \n            可以使用CDN，CDN的也是其他域   \n        - \\\u003cscript\u003e  \n            可以用于JSONP\n\n    \u003e Tips: 所有的跨域请求都必须经过信息提供方允许  \n    如果未经允许即可获取，那是浏览器同源策略出现漏洞\n\n- JSONP实现原理\n    - 加载http://coding.m.imooc.com/classindex.html  \n    - 不一定服务器真正有一个classindex.html文件\n    - 服务器可以根据请求，动态生成一个文件，返回  \n    - 同理于\\\u003cscript src = 'http://coding.m.imooc.com/api.js'\u003e\n        ```js\n        window.callback = function (data) {\n            //这是我们跨域得到的信息\n            console.log(data);\n        }\n        \u003cscript src = 'http://coding.m.imooc.com/api.js'\u003e\n        \u003c!-- 以上将返回 callback({x:100, y:200}) --\u003e\n        ```\n\n- 服务器端设置 http header\n    ```php\n    // 第二个参数填写允许跨域的域名，不建议直接写 \"*\"\n    response.setHeader(\"Access-Control-Allow-Origin\", \"http://a.com, http://b.com\");\n    response.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n    response.setHeader(\"Access-Control-Allow-Methods\", \"PUT, POST, GET, DELETE, OPTIONS\");\n\n    // 接收跨域cookie\n    response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n    ```\n- 解题\n    - 手动编写一个ajax，不依赖第三方库\n        ```js\n        var xhr = new XMLHttpRequest()\n        xhr.open(\"GET\", \"./api\", false)\n        xhr.onreadystatechange = function () {\n            //这里的函数异步执行\n            if (xhr.readyState == 4) {\n                if (xhr.status == 200) {\n                    console.log(xhr.responseText);\n                }\n            }\n        }\n        xhr.send(null)\n        ```\n    - 跨域的几种实现方式\n        - JSONP\n        - 服务器端设置 http header\n\n## 存储\n\n    请描述一下 cookie、 sessionStorage 和 localStorage 的区别？  \n    \u003e 容量、是否会携带到ajax中、API易用性  \n    \n- cookie  \n    - 用于客户端和服务器通信  \n    - 但是它有本地存储的功能，于是就被『借用』  \n    - 使用 document.cookie = ... 获取和修改即可\n    ### 缺点\n    - 存储太小，只有4KB  \n    - 所有http请求都带着，会影响获取资源的效率  \n    - API简单，需要封装才能用 document.cookie = ...\n-  localStorage 和 sessionStorage\n    - HTML5 专门为存储而设计，最大容量 5M  \n    - API简洁易用：  \n        - localStorage.setItem(key, value);  \n        - localStorage.getItem(key);\n\n    \u003e iOS safari 隐藏模式下 localStorage.getItem 会报错  \n    建议统一使用 try-catch 封装\n\n# 开发环境\n## IDE（ 写代码效率 ）  \n- webstorm 收费，功能强大\n- sublime 免费，轻量级，性能好\n- vscode　免费，轻量级，针对前端推出，微软出品\n- atom　免费，GitHub出品\n- 插件插件插件！！\n## GIT（ 代码版本管理，多人协作开发 ）  \n    正式项目都需要代码版本管理  \n    大型项目需要多人协作开发  \n    Git和Linux是一个作者\n    网络Git服务器：coding.net、github.com  \n    一般公司代码非开源，都有自己的Git服务器\n- 常用Git命令\n    ```js\n    git add\n    git checkout xxx //切换分支\n    git commit -m \"xxx\"\n    git push origin master\n    git pull origin master\n    git branch  //分支列表\n    git chechout -b xxx / git chechout xxx\n    git diff    //工作区与暂存区比较\n    git status\n    ```\n- 多人协作\n    ```js\n    git checkout -b xxx //新建并切换到xxx分支  \n    git merge xxx //合并当前分支和xxx分支\n    ```\n# JS模块化  \n\n## 不使用模块化的情况\n- utils.js getFormatDate函数  \n- a-utils.js aGetFormatDate函数 使用getFormatDate  \n- a.js aGetFormatDate  \n```js\n//util.js\nfunction getFormatDate(date, type) {\n    // type === 1 返回 2017-06-15\n    // type === 2 返回 2017年06月15日 格式\n    // ...\n}\n\n//a-utils.js\nfunction aGetFormatDate(date) {\n    // 要求返回 2017年06月15日 格式\n    return getFormatDate(date, 2)\n}\n\n//a.js\nvar dt = new Date()\nconsole.log(aGetFormatDate(dt));\n```\n```html\n\u003cscript src=\"utils.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"a-utils.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"a.js\"\u003e\u003c/script\u003e\n\n\u003c!-- 1. 这些代码中的函数必须是全局变量，才能暴露给使用方。全局变量污染 --\u003e\n\u003c!-- 2. a.js 知道要引用 a-utils.js，但是它知道还需要依赖于 utils.js吗？ --\u003e\n```\n## 使用模块化\n```js\n// util.js\nexport {\n    getFormatDate: function (date, type) {\n        // type === 1 返回 2017-06-15\n        // type === 2 返回 2017年06月15日 格式\n        // ...\n    }\n}\n// a-util.js\nvar getFormatDate = require('util.js')\nexport {\n    aGetFormatDate: function (date) {\n        // 要求返回 2017年06月15日 格式\n        return getFormatDate(date, 2)\n    }\n}\n// a.js\nvar aGetFormatDate = require(\"a-util.js\")\nvar dt = new Date()\nconsole.log(aGetFormatDate(dt));\n```\n## AMD\n\u003e 实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 \n\nrequire.js requirejs.org/  \n全局 define 函数  \n全局 require 函数  \n依赖 JS 会自动、异步加载\n\n```js\n// 使用require.js\n// util.js\ndefine(function() {\n    var util = {\n        getFormatDate: function (date, type) {\n            if (type === 1) {\n                return '2017-06-15'\n            }\n            if (type === 2) {\n                return '2018年05月10日'\n            }\n        }\n    }\n    return util\n});\n// a-util.js\ndefine(['./util.js'], function (util) {\n    var aUtil = {\n        aGetFormatDate: function (date) {\n            return util.getFormatDate(date, 2)\n        }\n    }\n    return aUtil\n});\n// a.js\ndefine(['./a-util.js'], function (aUtil) {\n    var a = {\n        printDate: function (date) {\n            console.log(aUtil.aGetFormatDate(date));\n        }\n    }\n    return a\n});\n// main.js\nrequire(['./a.js'], function (a) {\n    var date = new Date()\n    a.printDate(date)\n})\n```\n```html\n\u003cscript src=\"http://cdn.bootcss.com/require.js/2.2.3/require.min.js\" data-main=\"./main.js\"\u003e\u003c/script\u003e\n```\n\n## CommonJS\n\u003e nodejs 模块化规范  \n\n前端开发依赖的插件和库，都可以从 npm 中获取  \n构建工具的高度自动化，使得使用 npm 的成本非常低  \nCommonJS不会异步加载JS，而是同步一次性加载出来\n\n```js\n// 使用CommonJS\n// util.js\nmodule.exports = {\n    getFormatDate: function (date, type) {\n        if (type === 1) {\n            return '2017-06-15'\n        }\n        if (type === 2) {\n            return '2018年05月10日'\n        }\n    }\n}\n// a-util.js\nvar util = require('util.js')\nmodule.exports = {\n    aGetFormatDate: function (date) {\n        return util.getFormatDate(date, 2)\n    }\n}\n```\n## AMD 和 CommonJS 的使用场景\n- 需要异步加载JS，使用AMD  \n- 使用 npm 建议使用 CommonJS\n\n# 打包工具  \n- Grunt  \n- Gulp  \n- Fis3  \n- Webpack\n\n## 安装nodejs（移步nodejs官网）\n```\n\u003e node -v\n6.2.2\n\u003e npm -v\n3.9.5\n\u003e sudo npm install http-server -g\n\u003e http-server -p 8881\n```\n## 安装依赖\n```\n\u003e npm init\n\u003e npm install webpack --save-dev //安装webpack（保存，用于开发环境）\n\u003e npm i jquery --save\n\u003e npm i moment --save\n```\n## 卸载依赖\n```\n\u003e npm uninstall moment --save\n```\n## 配置webpack\n```js\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n    context: path.resolve(__dirname, './src')\n    entry: {\n        app: './app.js'\n    }\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'bundle.js'\n    }\n}\n// package.json\n{\n    \"script\": {\n        \"start\": \"webpack\"\n    }\n}\n// command\n\u003e npm start\n```\n\n## 使用jquery\n```js\n// package.json 确认已安装jquery\n{\n    \"dependencies\": {\n        \"jquery\": \"^3.2.1\"\n    }\n}\n// app.js\nvar $ = require('jquery')\nvar root = $('#root')\n$root.html('\u003cp\u003e这是jquery插入的文字\u003c/p\u003e')\n```\n## 使用自定义CommonJS模块\n```js\n// 自定义模块 a-util.js\nmodule.exports = {\n    print: function () {\n        console.log(123)\n    }\n}\n// app.js\nvar aUtil = require('./a-util.js')\naUtil.print()\n```\n## 压缩JS\n```js\n// webpack.config.js\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n    context: path.resolve(__dirname, './src')\n    entry: {\n        app: './app.js'\n    }\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: 'bundle.js'\n    }\n    plugins: [\n        new webpack.optimize.UglifyJsPlugin()\n    ]\n}\n// command\n\u003e npm start\n```\n\n# 上线和回滚\n## 上线流程  \n- 将测试完成的代码提交到git版本库的master分支\n- 将当前服务器的代码全部打包并记录版本号，备份\n- 将master分支的代码提交覆盖到线上服务器，生成新版本号\n## 回滚流程\n- 将当前服务器的代码全部打包并记录版本号，备份\n- 将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号\n## linux基本命令  \n    服务器使用linux居多，server版，只有命令行  \n    测试环境要匹配线上环境，因此也是linux  \n    经常登录测试机来自己配置、获取数据\n```\n\u003e ssh name@server   //登录服务器\n\u003e mkdir xxx //新建文件夹\n\u003e ls    //查看文件名字列表\n\u003e ll    //查看文件详细列表\n\u003e pwd   //显示当前目录\n\u003e rm xxx    //删除文件\n\u003e rm -rf xxx    //删除文件夹\n\u003e cp xxx xxx    //拷贝\n\u003e mv xxx xxx    //移动\n\u003e cat xxx   //打印文件内容\n\u003e head xxx   //打印文件开头内容\n    -n number   //选项，前几行\n\u003e tail xxx   //打印文件尾部内容\n\u003e grep xxx file //搜索\n```\n### VI、VIM命令\n```\ni 编辑模式\nesc 退出编辑\nw 保存\nq 退出\n```\n\n# 运行环境\n    浏览器可以通过访问链接来得到页面的内容  \n    通过绘制和渲染，显示出页面的最终的样子  \n    整个过程中，我们需要考虑什么问题？\n\n## 页面加载过程  \n-  从输入 url 到得到 html 的详细过程  \n\n    - 加载资源的形式  \n        - 输入url（或跳转页面）加载html  \n        - 加载html中的静态资源  \n\n    - 加载一个资源的过程  \n        - 浏览器根据DNS服务器得到域名的IP地址  \n        - 向这个IP的机器发用http(s)请求  \n        - 服务器收到、处理并返回http(s)请求  \n        - 浏览器得到返回内容  \n\n    - 浏览器渲染页面的过程  \n        - 根据 HTML 结构生成 DOM Tree  \n        - 根据 CSS 生成 CSSOM  \n        - 将 DOM 和 CSSOM 整合形成 RenderTree\n        - 根据 RenderTree 开始渲染和展示  \n        - 遇到 \\\u003cscript\u003e 时，会执行并阻塞渲染（因为JS有权改变DOM结构）  \n\n### window.onload 和 DOMContentLoaded 的区别  \n\n```js\nwindow.addEventListener('load', function() {\n    // 页面的全部资源加载完才会执行，包括图片、视频等\n})\ndocument.addEventListener('DOMContentLoaded', function() {\n    // DOM渲染完即可执行，此时图片、视频还可能没有加载完\n})\n```\n# 性能优化  \n    多使用内存、缓存或者其他方法  \n    减少CPU计算、\u0008减少网络请求\n\n## 加载页面和静态资源  \n- 静态资源的压缩合并\n- 静态资源缓存\n    ```html\n    \u003c!-- 通过链接名称控制缓存 --\u003e\n    \u003cscript src=\"abc_1.js\"\u003e\u003c/script\u003e\n    \u003c!-- 只有内容改变的时候，再改变链接名称 --\u003e\n    \u003cscript src=\"abc_2.js\"\u003e\u003c/script\u003e\n    ```\n- 使用CDN让资源加载更快（cdn.bootcss.com）\n- 使用 SSR（Server-Side-Render） 后端渲染，数据直接输出到 HTML 中\n    - Vue、React 提出了这样的概念\n    - JSP、PHP、ASP 都属于后端渲染\n## 页面渲染  \n- CSS 放在 HEAD 中，JS 放在 BODY 后面  \n- 懒加载（图片懒加载、下拉加载更多）\n    ```html\n    \u003cimg id=\"img1\" src=\"preview.png\" data-realsrc=\"abc.png\"/\u003e\n    \u003cscript\u003e\n        var img1 = document.getElementById(\"img1\")\n        img1.src = img1.getAttribute('data-realsrc')\n    \u003c/script\u003e\n    ```\n- 减少 DOM 查询，对 DOM查询做缓存\n    ```js\n    // 未缓存 DOM 查询\n    var i\n    for (i = 0; i \u003c document.getElementsByTagName('p').length; i++) {\n        //todo\n    }\n    // 缓存了 DOM 查询\n    var pList = document.getElementsByTagName('p')\n    var i\n    for (i = 0; i \u003c pList.length; i++) {\n        //todo\n    }\n    ```\n- 减少 DOM 操作，多个操作尽量合并在一起执行\n    ```js\n    var listNode = document.getElementById('list')\n    // 要插入 10 个 li 标签\n    var frag = document.createDocumentFragment();\n    var x, li;\n    for (i = 0; i \u003c 10; i++) {\n        li = document.createElement(\"li\")\n        li.innerHTML = \"List item \" + x;\n        frag.appendChind(li);\n    }\n    listNode.appendChild(frag)\n    ```\n- 事件节流\n    ```js\n    var textarea = document.getElementById('text')\n    var timeoutId\n    textarea.addEventListener('keyup', function () {\n        if (timeoutId) {\n            clearTimeout(timeoutId)\n        }\n        timeoutId = setTimeout(function () {\n            // 触发 change 事件\n        }, 100)\n    })\n    ```\n- 尽早执行操作（如 DOMContentLoaded）\n# 安全性\n    综合性的问题：常见的前端安全问题有哪些？\n\n## XSS 跨站请求攻击  \n    在博客写一篇文章，同时偷偷插入一段 \u003cscript\u003e  \n    攻击代码中，获取 cookie ，发送到自己的服务器\n    发布博客，有人查看内容\n    会把查看者的 cookie 发送到攻击者的服务器中\n- 替换关键字，例如替换 \u003c 为 \\\u0026lt; \u003e为 \\\u0026gt;\n## XSRF 跨站请求伪造\n    已登录一个购物网站，正在浏览商品\n    该网站付费接口是 xxx.com/pay?id=100 但是没有任何验证\n    然后你收到一封邮件，隐藏着 \u003cimg src=\"xxx.com/pay?id=100\"\u003e\n    你查看邮件的时候图片自动加载，就已经悄悄购买了\n- 增加验证流程，如输入指纹、密码、短信验证码","cover":"/blog/images/example-en.png","link":"lf_webfrontend.html","preview":"\u003cp\u003eLearningFiles 系列笔记 lf_webFrontend 前端笔记。欢迎大家参阅并提出宝贵意见。Github 仓库传送门：\u003ca href=\"前端基础知识汇总.md\"\u003e前端基础知识汇总.md\u003c/a\u003e\u003c/p\u003e\n","title":"学习资料 - 前端"},{"content":"\n\n## 纸小墨简介\n\n纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。\n\n![纸小墨 - 简洁的静态博客构建工具](/blog/images/example.png)\n\n### 开始上手\n\n- 下载并解压 [Ink](http://www.chole.io/)，运行命令 `ink preview`\n\n  \u003e 注意：Linux/macOS下，使用 `./ink preview`\n\n- 使用浏览器访问 `http://localhost:8000` 预览。\n\n### 特性介绍\n- YAML格式的配置\n- Markdown格式的文章\n- 无依赖跨平台\n- 超快的构建速度\n- 不断改善的主题与排版\n- 多文章作者支持\n- 归档与标签自动生成\n- 保存时实时预览页面\n- 离线的全文关键字搜索\n\n### 配置网站\n编辑`config.yml`，使用如下格式：\n\n``` yaml\nsite:\n    title: 网站标题\n    subtitle: 网站子标题\n    limit: 每页可显示的文章数目\n    theme: 网站主题目录\n    comment: 评论插件变量(默认为Disqus账户名)\n    root: 网站根路径 #可选\n    lang: 网站语言 #支持en, zh, ru, ja，可在theme/config.yml配置\n    url: 网站链接 #用于RSS生成\n    link: 文章链接形式 #默认为{title}.html，支持{year},{month},{day},{title}变量\n\nauthors:\n    作者ID:\n        name: 作者名称\n        intro: 作者简介\n        avatar: 作者头像路径\n\nbuild:\n    output: 构建输出目录 #可选, 默认为 \"public\"\n    port: 预览端口\n    copy:\n        - 构建时将会复制的目录/文件\n    publish: |\n        ink publish 命令将会执行的脚本\n```\n\n### 创建文章\n在`source`目录中建立任意`.md`文件（可置于子文件夹），使用如下格式：\n\n``` yaml\ntitle: 文章标题\ndate: 年-月-日 时:分:秒 #创建时间，可加时区如\" +0800\"\nupdate: 年-月-日 时:分:秒 #更新时间，可选，可加时区如\" +0800\"\nauthor: 作者ID\ncover: 题图链接 #可选\ndraft: false #草稿，可选\ntop: false #置顶文章，可选\npreview: 文章预览，也可在正文中使用\u003c!--more--\u003e分割 #可选\ntags: #可选\n    - 标签1\n    - 标签2\ntype: post #指定类型为文章(post)或页面(page)，可选\nhide: false #隐藏文章，只可通过链接访问，可选\n\n---\n\nMarkdown格式的正文\n```\n\n### 发布博客\n- 在博客目录下运行`ink publish`命令自动构建博客并发布。\n- 或运行`ink build`命令将生成的`public`目录下的内容手动部署。\n\n\u003e Tips: 在使用`ink preview`命令时，编辑保存文件后，博客会自动重新构建并刷新浏览器页面。\n\n## 定制支持\n\n### 修改主题\n\n默认主题在`theme`目录下，修改源代码后在该目录下运行`npm install`与`npm run build`重新构建。\n\n页面包含`page.html`（文章列表）及`article.html`（文章）等，所有页面均支持[GO语言HTML模板](http://golang.org/pkg/html/template/)语法，可引用变量。\n\n### 添加页面\n\n在`source`目录下创建的任意`.html`文件将被复制，这些文件中可引用`config.yml`中site字段下的所有变量。\n\n### 博客迁移(Beta)\n\n纸小墨提供简单的Jeklly/Hexo博客文章格式转换，使用命令：\n``` shell\nink convert /path/_posts\n```\n\n### 源码编译\n\n本地运行\n\n1. 配置[GO](http://golang.org/doc/install)语言环境。\n2. 运行命令`go get github.com/InkProject/ink`，编译并获取ink。\n3. 运行命令`ink preview $GOPATH/src/github.com/InkProject/ink/template`，预览博客。\n\nDocker构建（示例）\n\n1. Clone源码 `git clone git@github.com:InkProject/ink.git`。\n2. 源码目录下构建镜像`docker build -t ink .`。\n3. 运行容器`docker run -p 8000:80 ink`。\n\n## 主题\n\n- Dark(Official Theme): [https://github.com/InkProject/ink-theme-dark](https://github.com/InkProject/ink-theme-dark)\n- simple: [https://github.com/myiq/ink-simple](https://github.com/myiq/ink-simple)\n\n## 相关链接\n\n- [InkPaper 最佳实践](https://segmentfault.com/a/1190000009084954)\n\n## 反馈贡献\n\n纸小墨基于 [CC Attribution-NonCommercial License 4.0](https://creativecommons.org/licenses/by-nc/4.0/) 协议，目前为止它仍然是个非成熟的开源项目，非常欢迎任何人的任何贡献。如有问题可报告至 [https://github.com/InkProject/ink/issues](https://github.com/InkProject/ink/issues)。\n\n## 更新历史\n\n- [2016-07-11] 修复诸多Issue与合并一些PR。\n- [2015-08-15] 一些Bug修复，新增RSS订阅支持，主题改善。\n- [2015-07-04] 数项Bug修复与主题改善，支持置顶，多语言，子模板。\n- [2015-06-04] 编译更多平台版本，增加标签与存档页。\n- [2015-03-01] Beta版本，基础功能完成。\n\n## 更新计划\n\n- 排版深度优化\n- 纸小墨编辑器\n\n## 正在使用\n\n- [http://www.chole.io/blog/](http://www.chole.io/blog/)\n- [http://blog.hyper.sh/](http://blog.hyper.sh/)\n- [http://wangxu.me/](http://wangxu.me/)\n- [http://whzecomjm.com/](http://whzecomjm.com/)\n- [http://www.shery.me/blog/](http://www.shery.me/blog/)\n","cover":"/blog/images/example.png","link":"ink-blog-tool.html","preview":"\u003cp\u003e纸小墨（InkPaper）是一个GO语言编写的开源静态博客构建工具，可以快速搭建博客网站。它无依赖跨平台，配置简单构建快速，注重简洁易用与更优雅的排版。\u003c/p\u003e\n","title":"简洁的静态博客构建工具 —— 纸小墨（InkPaper）"},{"content":"\n\n## Introduce\n\nInkPaper is an static blog generator developed by Golang, No dependencies, Cross platform, Easy use, Fast build, Elegant theme.\n\n![InkPaper - An Elegant Static Blog Generator](/blog/images/example-en.png)\n\n### Quick Start\n- Download \u0026 Extract [Ink](http://www.chole.io/)，Run `ink preview`\n\n  \u003e Tips：Linux/macOS, use `./ink preview`\n\n- Open `http://localhost:8000` in browser to preview\n\n### Website Configuration\nEdit `config.yml`, use format:\n\n``` yaml\nsite:\n    title: Website Title\n    subtitle: Website Subtitle\n    limit: Max Article Count Per Page\n    theme: Website Theme Directory\n    comment: Comment Plugin Variable (Default is disqus username)\n    root: Website Root Path #Optional\n    lang: Website Language #Support en, zh, ru, ja, Configurable in theme/lang.yml\n    url: Website URL #For RSS Generating\n    link: Article Link Scheme #Default Is {title}.html，Support {year},{month},{day},{title} Variables\n\nauthors:\n    AuthorID:\n        name: Author Name\n        intro: Author Motto\n        avatar: Author Avatar Path\n\nbuild:\n    output: Build Output Directory #Optional, Default is \"public\"\n    port: Preview Port\n    copy:\n        - Copied Files When Build\n    publish: |\n        Excuted command when use 'ink publish'\n```\n\n### Writing\nCreate any `.md` file in `source` directory (Support subdirectory), use format:\n\n``` yaml\ntitle: Article Title\ndate: Year-Month-Day Hour:Minute:Second #Created Time，Support TimeZone, such as \" +0800\"\nupdate: Year-Month-Day Hour:Minute:Second #Updated Time，Optional，Support TimeZone, such as \" +0800\"\nauthor: AuthorID\ncover: Article Cover Path #Optional\ndraft: false #If Draft，Optional\ntop: false #Place article to top, Optional\npreview: Article Preview，Also use \u003c!--more--\u003e to split in body #Optional\ntags: #Optional\n    - Tag1\n    - Tag2\ntype: post #Specify type is post or page, Optional\nhide: false #Hide article，can be accessed via URL, Optional\n\n---\n\nMarkdown Format's Body\n```\n\n### Publish\n- Run `ink publish` in blog directory to automatically build and publish\n- Or run `ink build` to manually deploy generated `public` directory\n\n\u003e **Tips**: When files changed，`ink preview` will automatically rebuild blog，refresh browser to update.\n\n## Customization\n\n### Modify Theme\n\nDefault theme placed in `theme` folder, run `npm install` and `npm run build` to rebuild in this folder.\n\npage `page.html` (article list) and `article.html` (article), use variable with [Golang Template](http://golang.org/pkg/html/template/) syntax.\n\n### New Page\n\nCreated any `.html` file will be copied to `source` directory, could use all variables on `site` field in `config.yml`.\n\n### Blog Migrate (Beta)\n\nSupport simple Jeklly/Hexo post convert, use:\n\n``` shell\nink convert /path/_posts\n```\n\n### Build from source\n\nLocal Build\n\n1. Install [Golang](http://golang.org/doc/install) environment\n2. Run `go get github.com/InkProject/ink`, compile and get ink\n3. Run `ink preview $GOPATH/src/github.com/InkProject/ink/template`, preview blog\n\nDocker Build (Example)\n\n1. Clone code `git clone git@github.com:InkProject/ink.git`\n2. Build image `docker build -t ink .` in source directory\n3. Run container `docker run -p 8888:80 ink`\n\n## Theme\n\n- Dark(Official Theme): [https://github.com/InkProject/ink-theme-dark](https://github.com/InkProject/ink-theme-dark)\n- simple: [https://github.com/myiq/ink-simple](https://github.com/myiq/ink-simple)\n\n## Related Toturials\n\n- [Automatically deploy your Ink blog to GitHub pages wiht Travis CI](http://www.shery.me/blog/travis-ci.html)\n\n## Issue Report\n\n[CC Attribution-NonCommercial License 4.0](https://creativecommons.org/licenses/by-nc/4.0/)\n\n[https://github.com/InkProject/ink/issues](https://github.com/InkProject/ink/issues)\n\n## Change Log\n\n- [2016-07-11] Fix bugs and merge many PRs\n- [2015-08-15] Bug fix, support RSS feed, improve theme\n- [2015-07-04] Bug fix, improve theme, support top, i18n, subtemplate\n- [2015-06-04] Build more platform, add archive and tag page\n- [2015-03-01] Release first beta version\n\n## Develop Plan\n\n- Improve Theme\n- InkPaper Editor\n\n## They are using\n\n- [http://www.chole.io/blog/](http://www.chole.io/blog/)\n- [http://blog.hyper.sh/](http://blog.hyper.sh/)\n- [http://wangxu.me/](http://wangxu.me/)\n- [http://whzecomjm.com/](http://whzecomjm.com/)\n- [http://www.shery.me/blog/](http://www.shery.me/blog/)\n","cover":"/blog/images/example-en.png","link":"ink-blog-tool-en.html","preview":"\u003cp\u003eInkPaper is an static blog generator developed by Golang, No dependencies, Cross platform, Easy use, Fast build, Elegant theme.\u003c/p\u003e\n","title":"An Elegant Static Blog Generator —— InkPaper"}]