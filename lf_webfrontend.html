<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1, minimum-scale=1, maximum-scale=1">
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">
<meta name="robots" content="index,follow">


<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赵大仁的博客">
<meta name="twitter:description" content="生活、技术、内心戏">
<meta name="twitter:image:src" content="http://boyzhaotian.github.io/blog/blog/images/sail.jpeg">

<meta property="og:url" content="http://boyzhaotian.github.io/blog">
<meta property="og:title" content="赵大仁的博客">
<meta property="og:description" content="生活、技术、内心戏">
<meta property="og:site_name" content="赵大仁的博客">
<meta property="og:image" content="http://boyzhaotian.github.io/blog/blog/images/sail.jpeg">
<meta property="og:type" content="website">
<meta name="robots" content="noodp">

<meta itemprop="name" content="赵大仁的博客">
<meta itemprop="description" content="生活、技术、内心戏">
<meta itemprop="image" content="http://boyzhaotian.github.io/blog/blog/images/sail.jpeg">

<link rel="canonical" href="http://boyzhaotian.github.io/blog">

<link rel="shortcut icon" href="/blog/favicon.png">
<link rel="apple-itouch-icon" href="/blog/favicon.png">
<link rel="stylesheet" href="/blog/bundle/index.css">
<script type="text/javascript">
    var timeSinceLang = {
        year: '年前',
        month: '个月前',
        day: '天前',
        hour: '小时前',
        minute: '分钟前',
        second: '秒前'
    };
    var root = '\/blog';
</script>

<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fc6b8a73ded8eee609cce7c1ceb87ec8";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>
        <meta name="keywords" content="学习,前端,">
        <meta name="description" content="学习资料 - 前端">
        <meta name="author" content="赵大仁">
        <title>学习资料 - 前端</title>
    </head>
    <body>
        <article class="container">
            <header class="header-wrap">
  <a class="index" href="/blog/">
    <img class="logo" src="/blog/images/sail.jpeg" />
    赵大仁的博客
  </a>
  <ul class="menu">
      <li class="menu-item"><a href="/blog/archive.html">归档</a></li>
      <li class="menu-item"><a href="/blog/tag.html">标签</a></li>
      <li class="menu-item"><a href="/blog/atom.xml">订阅</a></li>
  </ul>
</header>

            <article class="main article">
                <h1 class="title">学习资料 - 前端</h1>
                <section class="info">
                    <span class="avatar" style="background-image: url(/blog/images/sail.jpeg);"></span>
                    <a class="name" href="/blog/about.me.html">赵大仁</a>
                    
                    <span class="date" data-time="1527050400"><span class="from"></span></span>
                    
                    <span class="tags"><a class="tag" href="/blog/tag/%e5%ad%a6%e4%b9%a0/index.html">学习</a><a class="tag" href="/blog/tag/%e5%89%8d%e7%ab%af/index.html">前端</a></span>
                </section>
                <article class="content"><h1>变量类型和计算</h1>

<pre><code>JS 中使用 typeof 能得到哪些类型
何时使用 === 何时使用 == 
JS 中有哪些内置函数
JS 变量按照存储方式区分为哪些类型，并描述特点
如何理解JSON
</code></pre>

<h2>变量类型</h2>

<ul>
<li><p>值类型 vs 引用类型</p>

<pre><code class="language-js">// 值类型
var a = 100
var b = a
a = 200
console.log(b)  // 100

// 引用类型 
// 对象、数组、函数，都具有对象特性，可无限扩展属性
var a = {age:20}
var b = a
b.age = 21
console.log(a.age)  // 21
</code></pre></li>

<li><p>typeof 运算符详解</p>

<pre><code class="language-js">typeof undefined    // undefined
typeof 'abc'    // string
typeof 123    // number
typeof true    // boolean
// type 只能区分值类型
typeof {}    // object
typeof []    // object
typeof null    // object
// 不能区分引用类型
typeof console.log()    // function
</code></pre>

<h2>变量计算</h2></li>

<li><p>强制类型转换</p>

<ul>
<li>字符串拼接
<code>js
var a = 100 + 10    // 110
var b = 100 + '10'  // '10010'
</code></li>
<li>== 运算符 （ 判断值相等 ）
<code>js
100 == '100'    // true
0 == ''  // true
null == undefined   //true
</code></li>
<li>if 语句
<code>js
var a = true
if (a) {    // true
    // ...
}
var b = 100
if (b) {    // true
    // ...
}
var c = ''
if (c) {    // false
    // ...
}
</code></li>

<li><p>逻辑运算</p>

<pre><code class="language-js">console.log(10 &amp;&amp; 0)   // 0
console.log('' &amp;&amp; 'abc')   // 'abc'
console.log(!window.abc)   // true

// 判断一个变量会被当做 true 还是 false
var a = 100
console.log(!!a)   // true
</code></pre>

<blockquote>
<p>if中强制转换成false的有：0、&rdquo;、NaN、null、false</p>
</blockquote></li>
</ul></li>
</ul>

<h3>何时使用 === 和 ==</h3>

<pre><code class="language-js">// 除了下面情况，全部使用 === 判断相等
if (obj.a == null) {
    // 这里相当于 obj.a === null || obj.a === undefined ，简写形式
    // 这是 jquery 源码中推荐的写法
}
</code></pre>

<blockquote>
<p>看对象属性是否存在的时候用 == null（对象属性不存在不会报错）</p>
</blockquote>

<h3>JS中的内置函数 —— 数据封装类对象</h3>

<pre><code class="language-js">Function
Array
Object
Date
RegExp
Boolean
Number
Error
</code></pre>

<h3>内置对象：Math、JSON（两个API）</h3>

<pre><code class="language-js">// JSON 是一种数据格式 也是 JS 对象
JSON.stringify({a:10, b:20})
JSON.parse('{&quot;a&quot;:10,&quot;b&quot;:20}')
</code></pre>

<h1>原型链</h1>

<pre><code>如何准确判断一个变量是数组类型
写一个原型链继承的例子
描述 new 一个对象的过程
zepto（ 或其他框架 ）代码中如何使用原型链
</code></pre>

<h2>构造函数</h2>

<pre><code class="language-js">function Foo(name, age) {
    this.name = name
    this.age = age
    this.class = 'class-1'
    // return this  // 默认有这行
}
var f = new Foo('zhangsan', 20)
//var f = new Foo('lisi', 22)   // 创建多个对象
</code></pre>

<ul>
<li><p>new 的过程 this</p>

<pre><code class="language-js">// 生成空对象 this ，添加属性，返回 this
function Foo(name, age) {
    // this = {}
    this.age = age
    // return this  
}
</code></pre>

<h2>构造函数 - 扩展</h2></li>

<li><p>var a = {} 其实是 var a = new Object() 的语法糖</p></li>

<li><p>var a = [] 其实是 var a = new Array() 的语法糖</p></li>

<li><p>functino Foo(){&hellip;} 其实是 var Foo = new Function(&hellip;) 的语法糖</p></li>

<li><p>使用 instanceof 判断一个函数是否是一个变量的构造函数</p>

<h2>原型规则和示例</h2></li>

<li><p>所有的引用类型（数组、对象、函数），都具有对象是特性，即可以自由扩展属性（除了&rdquo;null&rdquo;以外）</p>

<pre><code class="language-js">var obj = {}; obj.a = 100;
var arr = []; arr.a = 100;
function fn () {}
fn.a = 100;
</code></pre></li>

<li><p>所有的引用类型（数组、对象、函数），都有一个隐式原型<strong>proto</strong>属性，属性是一个普通对象。</p>

<pre><code class="language-js">console.log(obj.__proto__);
console.log(arr.__proto__);
console.log(fn.__proto__);
</code></pre></li>

<li><p>所有的函数，都有一个显式原型protoype属性，属性值也是一个普通对象。</p>

<pre><code class="language-js">console.log(fn.prototype);
</code></pre></li>

<li><p>所有的引用类型（数组、对象、函数），隐式原型<strong>proto</strong>属性指向它的构造函数的显式原型prototype属性。</p>

<pre><code class="language-js">console.log(obj.__proto__ === Object.prototype);
</code></pre></li>

<li><p>当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去他的<strong>proto</strong>（即它的构造函数的prototype）中去找。</p>

<pre><code class="language-js">function Foo(name, age) {
    this.name = name
}
Foo.prototype.alertName = function () {
    alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function () {
    console.log(this.log)
}
// 测试
f.printName()
f.alertName()
</code></pre>

<h3>循环对象的自身属性</h3>

<pre><code class="language-js">var item
for (item in f) {
// 高级浏览器已经在 for ... in 中屏蔽了来自原型的属性
// 但是建议大家还是加上这个判断，保证程序的健壮性
if (f.hasOwnProperty(item)) {
    console.log(item)
}
}
</code></pre></li>
</ul>

<h2>原型链</h2>

<!-- ![image](https://boyzhaotian.netlify.com/原型链.png) -->

<pre><code class="language-js">function Foo(name, age) {
    this.name = name
}
Foo.prototype.alertName = function () {
    alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function () {
    console.log(this.log)
}
// 测试
f.printName()
f.alertName()
f.toString()    // 要去 f.__proto__.__proto__中查找
</code></pre>

<blockquote>
<p>原型链为防止死循环： Object.prototype.__proto__ === null</p>
</blockquote>

<h2>instanceof</h2>

<ul>
<li>f instanceof Foo 的判断逻辑是

<ul>
<li>f 的 <strong>proto</strong> 一层一层往上，能否对应到 Foo.prototype</li>
<li>再试着判断 f instanceof Object</li>
</ul></li>
</ul>

<blockquote>
<p>f instanceof Foo、Object都为true</p>
</blockquote>

<h2>解答</h2>

<ul>
<li>如何准确判断一个变量是数组类型？
<code>js
var arr = []
arr instanceof Array    // true
typeof arr  // object，typeof 是无法判断是否是数组的
</code></li>
<li>写一个原型链继承的例子
<code>js
function Elem(id) {
    this.elem = document.getElementById(id)
}
Elem.prototype.html = function (val) {
    var elem = this.elem
    if (val) {
        elem.innerHTML = val
        return this //链式操作
    } else {
        return elem.innerHTML
    }
}
Elem.prototype.on = function (type, fn) {
    var elem = this.elem
    elem.addEventListener(type, fn)
    return this
}
var div1 = new Elem('div1')
div1.html('&lt;p&gt;hello&lt;/p&gt;').on('click', function(){
    console.log('clicked')
}).html('&lt;p&gt;javascript&lt;/p&gt;')
</code></li>
<li>描述 new 一个对象的过程

<ul>
<li>创建一个新对象</li>
<li>this 指向这个新对象</li>
<li>执行代码，即对 this 赋值</li>
<li>返回 this</li>
</ul></li>
<li>zepto（ 或其他框架 ）源码中如何使用原型链

<ul>
<li>阅读源码是高效提高技能的方式</li>
<li>但不能『埋头苦钻』有技巧在其中</li>
<li>慕课网搜索『zeoto设计和源码分析』</li>
</ul></li>
</ul>

<h1>作用域（Scope）和闭包（Closure）</h1>

<pre><code>说一下对变量提升的理解
说明 this 几种不同的使用场景
创建 10 个 &lt;a&gt; 标签，点击的时候弹出来对应的序号
如何理解作用域
实际开发中闭包的应用
</code></pre>

<h2>执行上下文</h2>

<ul>
<li><p>执行上下文深入理解</p>

<p><a href="https://www.cnblogs.com/wangfupeng1988/p/3986420.html">深入理解javascript原型和闭包（8）——简述【执行上下文】上</a></p></li>

<li><p>执行上下文和作用域的关系<br />
在一个函数被执行时，创建的执行上下文对象除了保存了些代码执行的信息，还会把当前的作用域保存在执行上下文中。所以它们的关系只是存储关系。</p></li>
</ul>

<pre><code class="language-js">console.log(a)  // undefined
var a = 100

fn('zhangsan')  // 'zhangsan' 20
function fn (name) {
    age = 20
    console.log(name, age)
    var age
}
</code></pre>

<ul>
<li>范围：一段&lt;script&gt;或者一个函数<br /></li>
<li>全局：变量定义、函数声明（一段&lt;script&gt;）<br /></li>
<li>函数：变量定义、函数声明、this赋值、arguments（函数）<br />
&gt; 注意函数声明和函数表达式的区别</li>
</ul>

<h2>THIS</h2>

<ul>
<li>this 指向要在执行时才能确认值，定义时无法确认
<code>js
var a = {
    name: 'A',
    fn: function () {
        console.log(this.name);
    }
}
a.fn()  // this === a
a.fn.call({name: 'B'})  // this === {name: 'B'}
var fn1 = a.fn
fn1() // this === window
</code></li>
<li>使用场景

<ul>
<li>作为构造函数执行 -&gt; 实例</li>
<li>作为对象属性执行 -&gt; 引用者</li>
<li>作为普通函数执行 -&gt; window</li>
<li>call、apply、bind -&gt; 传入的第一个参数</li>
</ul></li>
</ul>

<h2>作用域（Scope）</h2>

<ul>
<li>JS没有块级作用域
<code>js
// 无块级作用域
if (true) {
    var name = 'zhangsan'
}
console.log(name);  // zhangsan
</code></li>
<li>只有函数和全局作用域
<code>js
// 函数和全局作用域
var a = 100
function fn() {
    var a = 200
    console.log('fn', a);
}
console.log('global', a);   // global 100
fn()    // fn 200
</code></li>
</ul>

<h2>作用域链</h2>

<ul>
<li>即自由变量的查找路径<br /></li>

<li><p>函数的父级作用域根据定义的位置来判断，并非执行位置。</p>

<h3>自由变量</h3>

<pre><code class="language-js">var a = 100
function F1() {
var b = 200
function F2() {
    var c = 300
    // 当前作用域没有定义的变量，即&quot;自由变量&quot;
    console.log(a); // a 是自由变量
    console.log(b); // b 是自由变量
    console.log(c);
}
F2()
}
F1()
</code></pre></li>
</ul>

<h2>闭包</h2>

<ul>
<li><p>使用场景</p>

<ul>
<li>函数作为返回值
<code>js
function F1() {
    var a = 100
    // 返回一个函数（函数作为返回值）
    return funtion () {
        console.log(a)  // 自由变量，父作用域寻找
    }
}
// f1 得到一个函数
var f1 = F1()
var a = 200
fn()    // 100
</code></li>

<li><p>函数作为参数传递</p>

<pre><code class="language-js">function F1 () {
    var a = 100
    // 返回一个函数（函数作为返回值）
    return funtion () {
        console.log(a)  // 自由变量，父作用域寻找
    }
}
var f1 = F1()
function F2（fn）{
    var a = 200
    fn()
}
F2(f1)
</code></pre>

<h2>解题</h2></li>
</ul></li>

<li><p>说一下对变量提升的理解</p>

<ul>
<li>变量定义</li>
<li>函数声明（ 注意和函数表达式的区别 ）</li>
</ul></li>

<li><p>说明 this 几种不同的使用场景</p>

<ul>
<li>作为构造函数执行 -&gt; 实例</li>
<li>作为对象属性执行 -&gt; 引用者</li>
<li>作为普通函数执行 -&gt; window</li>
<li>call、apply、bind -&gt; 传入的第一个参数</li>
</ul></li>

<li><p>创建 10 个 &lt;a&gt; 标签，点击的时候弹出来对应的序号</p>

<pre><code class="language-js">var i, frag = document.createDocumentFragment()
for (i = 0; i &lt; 10; i++) {
    (function (i) {
        var a = document.createElement('a')
        a.innerHTML = i + '&lt;br&gt;'
        a.addEventListener('click', function (e) {
            e.preventDefault()
            alert(i)
        })
        frag.appendChild(a)
    })(i)
}
document.body.appendChild(frag)
</code></pre></li>

<li><p>如何理解作用域</p>

<ul>
<li>自由变量</li>
<li>作用域链，即自由变量的查找</li>
<li>闭包的两个场景</li>
</ul></li>

<li><p>实际开发中的闭包应用</p>

<ul>
<li>封装变量</li>
<li>收敛权限
<code>js
function isFirstLoad() {
var _list = []
return function (id) {
    if (_list.indexOf(id) &gt;= 0) {
        return false
    } else {
        _list.push(id)
        return true
    }
}
}
var firstLoad = isFirstLoad()
firstLoad(10) //true
firstLoad(10) //false
firstLoad(20) //true
firstLoad(20) //false
// 在 isFirstLoad 函数外面，根本不可能修改掉 _list 的值
</code></li>
</ul></li>
</ul>

<h1>异步和单线程</h1>

<pre><code>同步和异步的区别是什么？分别举一个同步和异步的例子  
一个关于 setTimeout 的笔试题
前端使用异步的场景有哪些
</code></pre>

<ul>
<li>什么是异步（ 对比同步 ）
<code>js
console.log(100)
setTimeout(function () {
    console.log(200)
}, 1000)    // 异步
alert(300)  // 同步阻塞
console.log(400)
</code>

<ul>
<li>何时需要异步

<ul>
<li>在可能发生等待的情况</li>
<li>等待过程中不能像 alert 一样阻塞程序运行</li>
<li>因此，所有的『等待的情况』都需要异步</li>
</ul></li>
</ul></li>

<li><p>前端使用异步的场景</p>

<ul>
<li>定时任务：setTimeout，setInterval<br />
```js
setTimeout(function () {</li>
</ul>

<p>}, 0)</p>

<pre><code>
- 网络请求：ajax请求，动态\&lt;img&gt;加载  
```js
$.get('/test.json', function (data) {
    console.log(data)
})
var img = document.createElement('img')
img.onload = function () {
    console.log('loaded')
}
</code></pre>

<ul>
<li><p>事件绑定</p>

<pre><code class="language-js">var btn1 = document.getElementById('btn1')
btn1.addEventListener('click', function (e) {
console.log('clicked')
})
</code></pre>

<h2>解题</h2></li>
</ul></li>

<li><p>同步和异步的区别是什么？分别举一个同步和异步的例子</p>

<ul>
<li>同步会阻塞代码执行，而异步不会</li>
<li>alert 是同步的，setTimeout 是异步的</li>
</ul></li>

<li><p>一个关于 setTimeout 的笔试题</p></li>

<li><p>前端使用异步的场景有哪些</p>

<ul>
<li>定时任务：setTimeout，setInterval<br /></li>
<li>网络请求：ajax请求，动态&lt;img&gt;加载<br /></li>

<li><p>事件绑定</p>

<h1>日期和Math</h1>

<p>获取 2017-06-10 格式的日期
获取随机数，要求是长度已知的字符串格式
写一个能遍历对象和数组的通用 forEach 函数</p>

<h2>日期</h2>

<pre><code class="language-js">Date.now()  //获取当前时间毫秒数
var dt = new Date()
dt.getTime()    //获取毫秒数
dt.getFullYear()    //年
dt.getMonth()    //月（0 - 11）
dt.getDate()    //日（0 - 31）
dt.getHours()    //小时（0 - 23）
dt.getMinutes()    //分（0 - 59）
dt.getSeconds()    //秒（0 - 59）
</code></pre>

<h2>Math</h2></li>
</ul></li>

<li><p>获取随机数 Math.random() -&gt; [0-1]</p></li>
</ul>

<h1>数组和对象的API</h1>

<h2>数组</h2>

<ul>
<li>forEach 遍历所有元素<br />
<code>js
var arr = [1,2,3]
arr.forEach(function (item, index) {
    console.log(index, item)
})
</code></li>
<li>every 判断所有元素是否都符合条件<br />
<code>js
var arr = [1,2,3]
var result = arr.every(function (item, index) {
    if (item &lt; 2) {
        return true
    }
})
console.log(result) // false
</code></li>
<li>some 判断是否至少有一个元素符合条件<br />
<code>js
var arr = [1,2,3]
var result = arr.some(function (item, index) {
    if (item &lt; 2) {
        return true
    }
})
console.log(result) // true
</code></li>
<li>sort 排序<br />
<code>js
var arr = [1,4,2,3,5]
var result = arr.sort(function (a, b) {
    return a - b    // 从小到大
})
console.log(result)
</code></li>
<li>map 对元素重新组装，生成新数组
<code>js
var arr = [1,4,2,3,5]
var arr2 = arr.map(function (item, index) {
    return '&lt;b&gt;' + item + '&lt;/b&gt;'
})
console.log(result)
</code></li>

<li><p>filter 过滤符合条件的元素</p>

<pre><code class="language-js">var arr = [1,4,2,3,5]
var arr2 = arr.filter(function (item, index) {
    if (item &gt;= 2) {
        return true
    }
})
console.log(result)
</code></pre>

<h2>对象</h2></li>

<li><p>for&hellip;in 遍历对象</p>

<pre><code class="language-js">var obj = {
    a: 100,
    b: 200,
    c: 300
}
for (key in obj) {
    if (obj.hasOwnProperty(key)) {
        console.log(key, obj[key])
    }
}
</code></pre>

<h2>解答</h2></li>

<li><p>获取 2017-06-10 格式的日期</p>

<pre><code class="language-js">function formatDate(dt) {
    if (!dt) {
        dt = new Date()
    }
    var year = dt.getFullYear()
    var month = dt.getMonth() + 1
    var date = dt.getDate()
    if (month &lt; 10) {
        month = '0' + month
    }
    if (date &lt; 10) {
        date = '0' + date
    }
    return year + '-' + month + '-' + date
}
console.log(formatDate());
</code></pre></li>

<li><p>获取随机数，要求是长度已知的字符串格式</p>

<pre><code class="language-js">var random = Math.random()
var random = random + '0000000000'  // 后面加上 10 个零
var random = random.slice(0, 10)
console.log(random)
</code></pre></li>

<li><p>写一个能遍历对象和数组的通用 forEach 函数</p>

<pre><code class="language-js">function forEach(obj, fn) {
    var key
    if (obj instanceof Array) {
        obj.forEach(function (item, index) {
            fn(index, item)
        })
    } else {
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                fn(key, obj[key])
            }
        }
    }
}
var arr = [1,2,3]
forEach(arr, function (index, item) {
    console.log(index, item);
})
var obj = {x: 100, y:200}
forEach(obj, function (key, value) {
    console.log(key, value);    
})

</code></pre></li>
</ul>

<h1>JS-WEB API</h1>

<ul>
<li>JS基础知识：EMCA 262 标准（基础语法）

<ul>
<li>变量类型</li>
<li>原型</li>
<li>作用域和异步</li>
</ul></li>
<li>JS-WEB-API：W3C标准（基础库）<br />

<ul>
<li>浏览器操作页面的API

<ul>
<li>DOM操作<br /></li>
<li>BOD操作<br /></li>
<li>事件绑定<br /></li>
<li>ajax请求（包括http协议）<br /></li>
<li>存储<br /></li>
</ul></li>
<li>全局对象及函数<br />

<ul>
<li>Object, Array, Boolean, String, Math, JSON 等</li>
<li>window, document</li>
<li>navigator</li>
</ul></li>
</ul></li>
</ul>

<h2>DOM操作（Document Object Model）</h2>

<pre><code>DOM 是哪种基本结构？
DOM 操作常用 API 有哪些
DOM节点的 attr 和 property 有何区别？  
</code></pre>

<ul>
<li>DOM 本质
&gt; 就是将XML（或者HTML）内的节点定义成基本统一的对象数据可以供程序语言（如javaScript）控制的技术规范。</li>
<li>DOM 节点操作

<ul>
<li>获取 DOM 节点
<code>js
var div1 = document.getElementById('div1')  // 元素
var divList = document.getElementsByTagName('div')  // 集合
var divList = document.getElementsByClassName('div')  // 集合
var divList = document.querySelectorAll('div')  // 集合
</code></li>
<li>prototype
<code>js
var p = document.getElementById('p')  // 元素
console.log(p.style.width)  // 获取样式
p.style.width = '100px' // 修改样式
</code></li>
<li>Attribute
<code>js
var p = document.getElementById('p')  // 元素
console.log(p.getAttribute('data-name'))  // 获取样式
p.getAttribute('data-name') = 'p2' // 修改样式
</code></li>
</ul></li>
<li>DOM 结构操作

<ul>
<li>新增节点
<code>js
var div1 = document.getElementById('div1')
// 添加新节点
var p1 = document.createElement('p')
p1.innerHtml = 'this is p1'
div1.appendChild(p1)    // 添加新创建的元素
// 移动已有节点
var p2 = document.getElementById('p2')
div1.appendChild(p2)
</code></li>
<li>获取父元素
<code>js
var parent = div1.parentElement
</code></li>
<li>获取子元素
<code>js
var child = div1.childNodes
</code></li>
<li>删除节点
<code>js
div1.removeChild(child[0])
</code></li>
</ul></li>
</ul>

<h3>解题</h3>

<ul>
<li>DOM 是哪种基本结构？

<ul>
<li>树</li>
</ul></li>

<li><p>DOM 操作常用 API 有哪些</p>

<ul>
<li>获取 DOM 节点，以及节点的 property 和 attibute</li>
<li>获取父节点，获取子节点</li>
<li>新增节点，删除节点</li>
</ul></li>

<li><p>DOM节点的 attr 和 property 有何区别？</p>

<ul>
<li>property 只是一个 JS 对象的属性的修改<br /></li>
<li>Attribute 是对 html 标签属性的修改</li>
</ul></li>
</ul>

<h2>BOM操作（Browser Object Model）</h2>

<pre><code>如何检测浏览器类型 
拆解url的各部分
</code></pre>

<ul>
<li>如何检测浏览器类型<br />

<ul>
<li>navigator（userAgent）<br />
<code>js
var ua = navigator.userAgent
var isChrome = ua.indexOf('Chrome')
</code></li>
<li>screen（width、height）<br />
<code>js
console.log(screen.width)
console.log(screen.height)
</code></li>
</ul></li>

<li><p>拆解url的各部分</p>

<ul>
<li>location（href、protocol、pathname、search、hash）<br />
<code>js
console.log(location.href)
console.log(location.protocol)
console.log(location.host)
console.log(location.pathname)
console.log(location.search)
console.log(location.hash)
</code></li>

<li><p>history（back、forward）</p>

<pre><code class="language-js">history.back()
history.forward()
</code></pre>

<h2>事件</h2></li>
</ul>

<p>编写一个通用的事件监听函数
描述事件冒泡流程
冒泡的应用</p></li>

<li><p>编写一个通用的事件监听函数（ 通用事件绑定 ）</p>

<pre><code class="language-js">//通用事件绑定
function bindEvent (elem, type, fn) {
    elem.addEventListener(type, fn)
}
//通用事件绑定 + 事件代理
function bindEvent (elem, type, selector, fn) {
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, function (e) {
        var target
        if (selector) {
            target = e.target
            if (target.matches(selector)) {
                fn.call(target, e)
            }
        } else {
            fn(e)
        }
    })
}
var div1 = document.getElementById('div1')
bindEvent(div1, 'click', 'a', function(e) {
    console.log(this.innerHTML);
})
</code></pre>

<blockquote>
<p>关于IE低版本的兼容性<br />
IE低版本使用attachEvent绑定事件，和W3C标准不一样</p>
</blockquote></li>

<li><p>描述事件冒泡流程（事件冒泡）</p>

<ul>
<li>DOM树形结构<br /></li>
<li>事件冒泡<br /></li>
<li>阻止冒泡<br />

<ul>
<li>event.stopPropagation() 不再派发事件。<br />
终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。
<code>html
&lt;body&gt;
    &lt;div id = 'div1'&gt;
        &lt;p id = 'p1'&gt;激活&lt;/p&gt;
        &lt;p id = 'p2'&gt;取消&lt;/p&gt;
        &lt;p id = 'p3'&gt;取消&lt;/p&gt;
        &lt;p id = 'p4'&gt;取消&lt;/p&gt;
    &lt;/div&gt;
    &lt;div id = 'div2'&gt;
        &lt;p id = 'p5'&gt;取消&lt;/p&gt;
        &lt;p id = 'p6'&gt;取消&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code>
<code>js
var p1 = document.getElementById('p1')
var body = document.body
bindEvent(p1, 'click', function (e) {
    e.stopPropagation()
    alert('激活')
})
bindEvent(body, 'click', function (e) {
    e.stopPropagation()
    alert('取消')
})
</code></li>
</ul></li>
<li>冒泡的应用（代理）<br />

<ul>
<li>代码简洁</li>
<li>减少浏览器内存的占用
<code>html
&lt;div id = 'div1'&gt;
&lt;a href='#'&gt;a1&lt;/a&gt;
&lt;a href='#'&gt;a2&lt;/a&gt;
&lt;a href='#'&gt;a3&lt;/a&gt;
&lt;a href='#'&gt;a4&lt;/a&gt;
&lt;/div&gt;
</code>
<code>js
var div1 = document.getElementById('div1')
bindEvent(div1, 'click', function (e) {
var target = e.target
if (target.nodeName === 'A') {
    alert(trget.innerHTML)
}
})
</code></li>
</ul></li>
</ul></li>

<li><p>对于一个无限下拉加载图片的页面，如何绑定事件</p>

<ul>
<li>使用代理<br /></li>
<li>知道代理的两个优点（绑定次数少，浏览器压力小）<br /></li>
</ul></li>
</ul>

<h2>AJAX</h2>

<pre><code>手动编写一个ajax，不依赖第三方库
跨域的几种实现方式    
</code></pre>

<ul>
<li>XMLHttpRequest<br />
<code>js
var xhr = new XMLHttpRequest()
xhr.open(&quot;GET&quot;, &quot;./api&quot;, false)
xhr.onreadystatechange = function () {
    //这里的函数异步执行
    if (xhr.readyState == 4) {
        if (xhr.status == 200) {
            console.log(xhr.responseText);
        }
    }
}
xhr.send(null)
</code>
&gt; 关于IE低版本的兼容性<br />
IE低版本使用ActiveXObject，和W3C标准不一样</li>
<li>状态码说明

<ul>
<li>readyState<br />
0 - （未初始化）还没有调用send()方法<br />
1 - （载入）已调用send()方法，正在发送请求<br />
2 - （载入完成）send()方法执行完成，已经接收到全部响应内容<br />
3 - （交互）正在解析响应内容<br />
4 - （完成）响应内容解析完成，可以在客户端调用了</li>
<li>status<br />
2xx - 表示成功处理请求。如200<br />
3xx - 需要重定向，浏览器直接跳转<br />
4xx - 客户端请求错误，如404<br />
5xx - 服务器错误<br /></li>
</ul></li>

<li><p>跨域</p>

<ul>
<li>定义：浏览器有同源策略，不允许ajax访问其他域的接口<br /></li>
<li>跨域条件：协议、域名、端口，有一个不同就算跨域</li>
<li>可以跨域的三个标签

<ul>
<li>&lt;img&gt;<br />
用于打点统计，统计网站可能是其他域<br />
标签古老，不存在兼容性问题</li>
<li>&lt;link&gt;、&lt;script&gt;<br />
可以使用CDN，CDN的也是其他域<br /></li>
<li>&lt;script&gt;<br />
可以用于JSONP</li>
</ul></li>
</ul>

<blockquote>
<p>Tips: 所有的跨域请求都必须经过信息提供方允许<br />
如果未经允许即可获取，那是浏览器同源策略出现漏洞</p>
</blockquote></li>

<li><p>JSONP实现原理</p>

<ul>
<li>加载<a href="http://coding.m.imooc.com/classindex.html">http://coding.m.imooc.com/classindex.html</a><br /></li>
<li>不一定服务器真正有一个classindex.html文件</li>
<li>服务器可以根据请求，动态生成一个文件，返回<br /></li>
<li>同理于&lt;script src = &lsquo;<a href="http://coding.m.imooc.com/api.js'&gt;">http://coding.m.imooc.com/api.js'&gt;</a>
<code>js
window.callback = function (data) {
    //这是我们跨域得到的信息
    console.log(data);
}
&lt;script src = 'http://coding.m.imooc.com/api.js'&gt;
&lt;!-- 以上将返回 callback({x:100, y:200}) --&gt;
</code></li>
</ul></li>

<li><p>服务器端设置 http header</p>

<pre><code class="language-php">// 第二个参数填写允许跨域的域名，不建议直接写 &quot;*&quot;
response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://a.com, http://b.com&quot;);
response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);
response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT, POST, GET, DELETE, OPTIONS&quot;);

// 接收跨域cookie
response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
</code></pre></li>

<li><p>解题</p>

<ul>
<li>手动编写一个ajax，不依赖第三方库
<code>js
var xhr = new XMLHttpRequest()
xhr.open(&quot;GET&quot;, &quot;./api&quot;, false)
xhr.onreadystatechange = function () {
    //这里的函数异步执行
    if (xhr.readyState == 4) {
        if (xhr.status == 200) {
            console.log(xhr.responseText);
        }
    }
}
xhr.send(null)
</code></li>
<li>跨域的几种实现方式

<ul>
<li>JSONP</li>
<li>服务器端设置 http header</li>
</ul></li>
</ul></li>
</ul>

<h2>存储</h2>

<pre><code>请描述一下 cookie、 sessionStorage 和 localStorage 的区别？  
&gt; 容量、是否会携带到ajax中、API易用性  
</code></pre>

<ul>
<li><p>cookie</p>

<ul>
<li>用于客户端和服务器通信<br /></li>
<li>但是它有本地存储的功能，于是就被『借用』<br /></li>

<li><p>使用 document.cookie = &hellip; 获取和修改即可</p>

<h3>缺点</h3></li>

<li><p>存储太小，只有4KB</p></li>

<li><p>所有http请求都带着，会影响获取资源的效率</p></li>

<li><p>API简单，需要封装才能用 document.cookie = &hellip;</p></li>
</ul></li>

<li><p>localStorage 和 sessionStorage</p>

<ul>
<li>HTML5 专门为存储而设计，最大容量 5M<br /></li>
<li>API简洁易用：<br />

<ul>
<li>localStorage.setItem(key, value);<br /></li>
<li>localStorage.getItem(key);</li>
</ul></li>
</ul>

<blockquote>
<p>iOS safari 隐藏模式下 localStorage.getItem 会报错<br />
建议统一使用 try-catch 封装</p>
</blockquote></li>
</ul>

<h1>开发环境</h1>

<h2>IDE（ 写代码效率 ）</h2>

<ul>
<li>webstorm 收费，功能强大</li>
<li>sublime 免费，轻量级，性能好</li>
<li>vscode　免费，轻量级，针对前端推出，微软出品</li>
<li>atom　免费，GitHub出品</li>

<li><p>插件插件插件！！</p>

<h2>GIT（ 代码版本管理，多人协作开发 ）</h2>

<p>正式项目都需要代码版本管理<br />
大型项目需要多人协作开发<br />
Git和Linux是一个作者
网络Git服务器：coding.net、github.com<br />
一般公司代码非开源，都有自己的Git服务器</p></li>

<li><p>常用Git命令</p>

<pre><code class="language-js">git add
git checkout xxx //切换分支
git commit -m &quot;xxx&quot;
git push origin master
git pull origin master
git branch  //分支列表
git chechout -b xxx / git chechout xxx
git diff    //工作区与暂存区比较
git status
</code></pre></li>

<li><p>多人协作</p>

<pre><code class="language-js">git checkout -b xxx //新建并切换到xxx分支  
git merge xxx //合并当前分支和xxx分支
</code></pre>

<h1>JS模块化</h1></li>
</ul>

<h2>不使用模块化的情况</h2>

<ul>
<li>utils.js getFormatDate函数<br /></li>
<li>a-utils.js aGetFormatDate函数 使用getFormatDate<br /></li>
<li>a.js aGetFormatDate<br />
```js
//util.js
function getFormatDate(date, type) {
// type === 1 返回 2017-06-15
// type === 2 返回 2017年06月15日 格式
// &hellip;
}</li>
</ul>

<p>//a-utils.js
function aGetFormatDate(date) {
    // 要求返回 2017年06月15日 格式
    return getFormatDate(date, 2)
}</p>

<p>//a.js
var dt = new Date()
console.log(aGetFormatDate(dt));</p>

<pre><code>```html
&lt;script src=&quot;utils.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;a-utils.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;

&lt;!-- 1. 这些代码中的函数必须是全局变量，才能暴露给使用方。全局变量污染 --&gt;
&lt;!-- 2. a.js 知道要引用 a-utils.js，但是它知道还需要依赖于 utils.js吗？ --&gt;
</code></pre>

<h2>使用模块化</h2>

<pre><code class="language-js">// util.js
export {
    getFormatDate: function (date, type) {
        // type === 1 返回 2017-06-15
        // type === 2 返回 2017年06月15日 格式
        // ...
    }
}
// a-util.js
var getFormatDate = require('util.js')
export {
    aGetFormatDate: function (date) {
        // 要求返回 2017年06月15日 格式
        return getFormatDate(date, 2)
    }
}
// a.js
var aGetFormatDate = require(&quot;a-util.js&quot;)
var dt = new Date()
console.log(aGetFormatDate(dt));
</code></pre>

<h2>AMD</h2>

<blockquote>
<p>实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>
</blockquote>

<p>require.js requirejs.org/<br />
全局 define 函数<br />
全局 require 函数<br />
依赖 JS 会自动、异步加载</p>

<pre><code class="language-js">// 使用require.js
// util.js
define(function() {
    var util = {
        getFormatDate: function (date, type) {
            if (type === 1) {
                return '2017-06-15'
            }
            if (type === 2) {
                return '2018年05月10日'
            }
        }
    }
    return util
});
// a-util.js
define(['./util.js'], function (util) {
    var aUtil = {
        aGetFormatDate: function (date) {
            return util.getFormatDate(date, 2)
        }
    }
    return aUtil
});
// a.js
define(['./a-util.js'], function (aUtil) {
    var a = {
        printDate: function (date) {
            console.log(aUtil.aGetFormatDate(date));
        }
    }
    return a
});
// main.js
require(['./a.js'], function (a) {
    var date = new Date()
    a.printDate(date)
})
</code></pre>

<pre><code class="language-html">&lt;script src=&quot;http://cdn.bootcss.com/require.js/2.2.3/require.min.js&quot; data-main=&quot;./main.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h2>CommonJS</h2>

<blockquote>
<p>nodejs 模块化规范</p>
</blockquote>

<p>前端开发依赖的插件和库，都可以从 npm 中获取<br />
构建工具的高度自动化，使得使用 npm 的成本非常低<br />
CommonJS不会异步加载JS，而是同步一次性加载出来</p>

<pre><code class="language-js">// 使用CommonJS
// util.js
module.exports = {
    getFormatDate: function (date, type) {
        if (type === 1) {
            return '2017-06-15'
        }
        if (type === 2) {
            return '2018年05月10日'
        }
    }
}
// a-util.js
var util = require('util.js')
module.exports = {
    aGetFormatDate: function (date) {
        return util.getFormatDate(date, 2)
    }
}
</code></pre>

<h2>AMD 和 CommonJS 的使用场景</h2>

<ul>
<li>需要异步加载JS，使用AMD<br /></li>
<li>使用 npm 建议使用 CommonJS</li>
</ul>

<h1>打包工具</h1>

<ul>
<li>Grunt<br /></li>
<li>Gulp<br /></li>
<li>Fis3<br /></li>
<li>Webpack</li>
</ul>

<h2>安装nodejs（移步nodejs官网）</h2>

<pre><code>&gt; node -v
6.2.2
&gt; npm -v
3.9.5
&gt; sudo npm install http-server -g
&gt; http-server -p 8881
</code></pre>

<h2>安装依赖</h2>

<pre><code>&gt; npm init
&gt; npm install webpack --save-dev //安装webpack（保存，用于开发环境）
&gt; npm i jquery --save
&gt; npm i moment --save
</code></pre>

<h2>卸载依赖</h2>

<pre><code>&gt; npm uninstall moment --save
</code></pre>

<h2>配置webpack</h2>

<pre><code class="language-js">// webpack.config.js
var path = require('path')
var webpack = require('webpack')

module.exports = {
    context: path.resolve(__dirname, './src')
    entry: {
        app: './app.js'
    }
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: 'bundle.js'
    }
}
// package.json
{
    &quot;script&quot;: {
        &quot;start&quot;: &quot;webpack&quot;
    }
}
// command
&gt; npm start
</code></pre>

<h2>使用jquery</h2>

<pre><code class="language-js">// package.json 确认已安装jquery
{
    &quot;dependencies&quot;: {
        &quot;jquery&quot;: &quot;^3.2.1&quot;
    }
}
// app.js
var $ = require('jquery')
var root = $('#root')
$root.html('&lt;p&gt;这是jquery插入的文字&lt;/p&gt;')
</code></pre>

<h2>使用自定义CommonJS模块</h2>

<pre><code class="language-js">// 自定义模块 a-util.js
module.exports = {
    print: function () {
        console.log(123)
    }
}
// app.js
var aUtil = require('./a-util.js')
aUtil.print()
</code></pre>

<h2>压缩JS</h2>

<pre><code class="language-js">// webpack.config.js
var path = require('path')
var webpack = require('webpack')

module.exports = {
    context: path.resolve(__dirname, './src')
    entry: {
        app: './app.js'
    }
    output: {
        path: path.resolve(__dirname, './dist'),
        filename: 'bundle.js'
    }
    plugins: [
        new webpack.optimize.UglifyJsPlugin()
    ]
}
// command
&gt; npm start
</code></pre>

<h1>上线和回滚</h1>

<h2>上线流程</h2>

<ul>
<li>将测试完成的代码提交到git版本库的master分支</li>
<li>将当前服务器的代码全部打包并记录版本号，备份</li>

<li><p>将master分支的代码提交覆盖到线上服务器，生成新版本号</p>

<h2>回滚流程</h2></li>

<li><p>将当前服务器的代码全部打包并记录版本号，备份</p></li>

<li><p>将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号</p>

<h2>linux基本命令</h2>

<p>服务器使用linux居多，server版，只有命令行<br />
测试环境要匹配线上环境，因此也是linux<br />
经常登录测试机来自己配置、获取数据</p>

<pre><code>&gt; ssh name@server   //登录服务器
&gt; mkdir xxx //新建文件夹
&gt; ls    //查看文件名字列表
&gt; ll    //查看文件详细列表
&gt; pwd   //显示当前目录
&gt; rm xxx    //删除文件
&gt; rm -rf xxx    //删除文件夹
&gt; cp xxx xxx    //拷贝
&gt; mv xxx xxx    //移动
&gt; cat xxx   //打印文件内容
&gt; head xxx   //打印文件开头内容
-n number   //选项，前几行
&gt; tail xxx   //打印文件尾部内容
&gt; grep xxx file //搜索
</code></pre>

<h3>VI、VIM命令</h3>

<pre><code>i 编辑模式
esc 退出编辑
w 保存
q 退出
</code></pre></li>
</ul>

<h1>运行环境</h1>

<pre><code>浏览器可以通过访问链接来得到页面的内容  
通过绘制和渲染，显示出页面的最终的样子  
整个过程中，我们需要考虑什么问题？
</code></pre>

<h2>页面加载过程</h2>

<ul>
<li><p>从输入 url 到得到 html 的详细过程</p>

<ul>
<li><p>加载资源的形式</p>

<ul>
<li>输入url（或跳转页面）加载html<br /></li>
<li>加载html中的静态资源<br /></li>
</ul></li>

<li><p>加载一个资源的过程</p>

<ul>
<li>浏览器根据DNS服务器得到域名的IP地址<br /></li>
<li>向这个IP的机器发用http(s)请求<br /></li>
<li>服务器收到、处理并返回http(s)请求<br /></li>
<li>浏览器得到返回内容<br /></li>
</ul></li>

<li><p>浏览器渲染页面的过程</p>

<ul>
<li>根据 HTML 结构生成 DOM Tree<br /></li>
<li>根据 CSS 生成 CSSOM<br /></li>
<li>将 DOM 和 CSSOM 整合形成 RenderTree</li>
<li>根据 RenderTree 开始渲染和展示<br /></li>
<li>遇到 &lt;script&gt; 时，会执行并阻塞渲染（因为JS有权改变DOM结构）<br /></li>
</ul></li>
</ul></li>
</ul>

<h3>window.onload 和 DOMContentLoaded 的区别</h3>

<pre><code class="language-js">window.addEventListener('load', function() {
    // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentLoaded', function() {
    // DOM渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre>

<h1>性能优化</h1>

<pre><code>多使用内存、缓存或者其他方法  
减少CPU计算、减少网络请求
</code></pre>

<h2>加载页面和静态资源</h2>

<ul>
<li>静态资源的压缩合并</li>
<li>静态资源缓存
<code>html
&lt;!-- 通过链接名称控制缓存 --&gt;
&lt;script src=&quot;abc_1.js&quot;&gt;&lt;/script&gt;
&lt;!-- 只有内容改变的时候，再改变链接名称 --&gt;
&lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt;
</code></li>
<li>使用CDN让资源加载更快（cdn.bootcss.com）</li>

<li><p>使用 SSR（Server-Side-Render） 后端渲染，数据直接输出到 HTML 中</p>

<ul>
<li>Vue、React 提出了这样的概念</li>

<li><p>JSP、PHP、ASP 都属于后端渲染</p>

<h2>页面渲染</h2></li>
</ul></li>

<li><p>CSS 放在 HEAD 中，JS 放在 BODY 后面</p></li>

<li><p>懒加载（图片懒加载、下拉加载更多）</p>

<pre><code class="language-html">&lt;img id=&quot;img1&quot; src=&quot;preview.png&quot; data-realsrc=&quot;abc.png&quot;/&gt;
&lt;script&gt;
    var img1 = document.getElementById(&quot;img1&quot;)
    img1.src = img1.getAttribute('data-realsrc')
&lt;/script&gt;
</code></pre></li>

<li><p>减少 DOM 查询，对 DOM查询做缓存</p>

<pre><code class="language-js">// 未缓存 DOM 查询
var i
for (i = 0; i &lt; document.getElementsByTagName('p').length; i++) {
    //todo
}
// 缓存了 DOM 查询
var pList = document.getElementsByTagName('p')
var i
for (i = 0; i &lt; pList.length; i++) {
    //todo
}
</code></pre></li>

<li><p>减少 DOM 操作，多个操作尽量合并在一起执行</p>

<pre><code class="language-js">var listNode = document.getElementById('list')
// 要插入 10 个 li 标签
var frag = document.createDocumentFragment();
var x, li;
for (i = 0; i &lt; 10; i++) {
    li = document.createElement(&quot;li&quot;)
    li.innerHTML = &quot;List item &quot; + x;
    frag.appendChind(li);
}
listNode.appendChild(frag)
</code></pre></li>

<li><p>事件节流</p>

<pre><code class="language-js">var textarea = document.getElementById('text')
var timeoutId
textarea.addEventListener('keyup', function () {
    if (timeoutId) {
        clearTimeout(timeoutId)
    }
    timeoutId = setTimeout(function () {
        // 触发 change 事件
    }, 100)
})
</code></pre></li>

<li><p>尽早执行操作（如 DOMContentLoaded）</p>

<h1>安全性</h1>

<p>综合性的问题：常见的前端安全问题有哪些？</p></li>
</ul>

<h2>XSS 跨站请求攻击</h2>

<pre><code>在博客写一篇文章，同时偷偷插入一段 &lt;script&gt;  
攻击代码中，获取 cookie ，发送到自己的服务器
发布博客，有人查看内容
会把查看者的 cookie 发送到攻击者的服务器中
</code></pre>

<ul>
<li><p>替换关键字，例如替换 &lt; 为 &amp;lt; &gt;为 &amp;gt;</p>

<h2>XSRF 跨站请求伪造</h2>

<p>已登录一个购物网站，正在浏览商品
该网站付费接口是 xxx.com/pay?id=100 但是没有任何验证
然后你收到一封邮件，隐藏着 <img src="xxx.com/pay?id=100">
你查看邮件的时候图片自动加载，就已经悄悄购买了</p></li>

<li><p>增加验证流程，如输入指纹、密码、短信验证码</p></li>
</ul>
</article>
                <section class="author">
                    <div class="avatar" style="background-image: url(/blog/images/sail.jpeg);"></div>
                    <a class="name" href="/blog/about.me.html">赵大仁</a>
                    <div class="intro">君子性非异也，善假于物也。</div>
                </section>
                <section class="recommend">
                    
                    <section class="nav prev more">
                        <div class="head">上篇文章</div>
                        <a class="link" href="/blog/%e3%80%8chello%20world%e3%80%8d%20via%20ink.html">「Hello World」via Ink &amp; Travis CI</a>
                    </section>
                    
                    
                    <section class="nav next more">
                        <div class="head">下篇文章</div>
                        <a class="link" href="/blog/ink-blog-tool.html">简洁的静态博客构建工具 —— 纸小墨（InkPaper）</a>
                    </section>
                    
                </section>
                
    <section id="disqus_thread"></section>
    <script type="text/javascript">
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//username.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>


            </article>
        </article>
        <footer class="footer">
    <span class="copyright">
        赵大仁的博客 ©
        <script type="text/javascript">
            document.write(new Date().getFullYear());
        </script>
    </span>
    <span class="publish">Powered by <a href="http://www.chole.io/" target="_blank">Ink</a></span>
</footer>

        <script src="/blog/bundle/index.js"></script>
    </body>
</html>
